<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>{{ project.name }} - Graph</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/quill@1.3.7/dist/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/quill@1.3.7/dist/quill.min.js"></script>
    <style>
      /* Scoped styles for rendering sanitized comment HTML in the sidebar */
      #commentsList .comments-prose ul { list-style: disc; padding-left: 1.25rem; margin: 0.25rem 0 0.5rem; }
      #commentsList .comments-prose ol { list-style: decimal; padding-left: 1.25rem; margin: 0.25rem 0 0.5rem; }
      #commentsList .comments-prose li { margin: 0.125rem 0; }
      #commentsList .comments-prose li[data-indent="1"] { margin-left: 1.0rem; }
      #commentsList .comments-prose li[data-indent="2"] { margin-left: 2.0rem; }
      #commentsList .comments-prose li[data-indent="3"] { margin-left: 3.0rem; }
      #commentsList .comments-prose li[data-indent="4"] { margin-left: 4.0rem; }
      #commentsList .comments-prose p { margin: 0.25rem 0; }
      #commentsList .comments-prose h1 { font-size: 1rem; font-weight: 600; margin: 0.5rem 0 0.25rem; }
      #commentsList .comments-prose h2 { font-size: 0.95rem; font-weight: 600; margin: 0.5rem 0 0.25rem; }
      #commentsList .comments-prose h3 { font-size: 0.9rem; font-weight: 600; margin: 0.5rem 0 0.25rem; }
      #commentsList .comments-prose blockquote { border-left: 2px solid #cbd5e1; padding-left: 0.5rem; color: #475569; margin: 0.25rem 0; }
      #commentsList .comments-prose code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 0.875em; background: #f1f5f9; padding: 0 0.2em; border-radius: 3px; }
      #commentsList .comments-prose pre { background: #f8fafc; padding: 0.5rem; border-radius: 4px; overflow: auto; }
      #commentsList .comments-prose a { color: #2563eb; text-decoration: underline; }
    </style>
  </head>
  <body class="min-h-screen bg-slate-50 text-slate-900">
    <div class="flex flex-col h-screen">
      <div class="flex items-center justify-between px-4 py-3">
        <h1 id="projTitle" class="text-2xl font-semibold cursor-text" contenteditable="true" spellcheck="false">{{ project.name }}</h1>
        <div class="flex items-center gap-3">
          <span id="userEmail" class="text-sm text-slate-600 hidden"></span>
          <button id="btnLogin" class="px-3 py-1 bg-slate-700 text-white rounded">Login</button>
          <button id="btnLogout" class="px-3 py-1 bg-slate-500 text-white rounded hidden">Logout</button>
          <a class="text-blue-600 underline" href="/">Home</a>
        </div>
      </div>

      <div class="flex flex-1 overflow-hidden">
        <div class="flex-1 flex flex-col min-w-0">
          <div class="px-4 pb-3 flex flex-wrap gap-2 items-center">
            <input id="searchBox" type="text" placeholder="Search nodes..." class="border rounded px-2 py-1" />
            <select id="statusFilter" class="border rounded px-2 py-1">
              <option value="">All</option>
              <option value="planned">Todo</option>
              <option value="discuss">Discuss</option>
              <option value="in-progress">In Progress</option>
              <option value="done">Done</option>
              <option value="blocked">Blocked</option>
            </select>
            <button id="btnAddNode" class="px-3 py-1 bg-blue-600 text-white rounded">+ Node</button>
            <button id="btnAddEdge" class="px-3 py-1 bg-indigo-600 text-white rounded">+ Edge</button>
            <button id="btnCriticalPath" class="px-3 py-1 bg-teal-600 text-white rounded">Critical Path</button>
            <button id="btnGroup" class="px-3 py-1 bg-purple-600 text-white rounded">Group</button>
            <button id="btnUngroup" class="px-3 py-1 bg-purple-500 text-white rounded">Ungroup</button>
            <button id="btnCollapse" class="px-3 py-1 bg-fuchsia-600 text-white rounded">Collapse</button>
            <button id="btnExpand" class="px-3 py-1 bg-fuchsia-500 text-white rounded">Expand</button>
            <button id="btnFit" class="px-3 py-1 bg-slate-600 text-white rounded">Fit</button>
            
            <button id="btnScreenshot" class="px-3 py-1 bg-slate-700 text-white rounded">Screenshot</button>
            <button id="btnHelp" class="px-3 py-1 bg-slate-500 text-white rounded">Help</button>
            
            
            <button id="btnResetView" class="px-3 py-1 bg-slate-200 text-slate-800 rounded">Reset View</button>
            <button id="btnToggleSidebar" class="ml-auto px-3 py-1 bg-slate-200 text-slate-800 rounded">Toggle Sidebar</button>
          </div>
          <div class="relative flex-1 min-h-0 mx-4 mb-4">
            <div id="cy" class="absolute inset-0 bg-white rounded shadow z-0 pointer-events-auto"></div>
            <div class="absolute right-3 bottom-3 flex flex-col gap-2 z-30 pointer-events-auto">
              <button id="zoomIn" class="w-10 h-10 rounded bg-white/90 shadow text-xl">+</button>
              <button id="zoomOut" class="w-10 h-10 rounded bg-white/90 shadow text-xl">−</button>
            </div>
          </div>
        </div>
        <div id="resizer" class="w-1 cursor-col-resize bg-slate-200"></div>
        <aside id="sidebar" class="bg-white rounded-l-none rounded shadow p-3 space-y-3 overflow-auto" style="width: 384px;">
          <div class="flex items-center gap-2 mb-1">
            <button id="tabTask" class="px-2 py-1 text-xs rounded bg-slate-800 text-white">Task</button>
            <button id="tabActions" class="px-2 py-1 text-xs rounded bg-slate-200 text-slate-800">Actions</button>
            <button id="tabSettings" class="px-2 py-1 text-xs rounded bg-slate-200 text-slate-800">Settings</button>
          </div>
          <div id="taskPanel" class="space-y-3">
          <h2 class="font-medium text-sm">Task Panel</h2>

          <div id="taskSelectionLinkBlock" class="rounded border p-2 bg-white space-y-2">
            <button id="taskSelectionLinkToggle" type="button" class="w-full text-left font-semibold mb-1 flex items-center justify-between focus:outline-none focus:ring-0 rounded text-sm" aria-expanded="true" aria-controls="taskSelectionLinkBody">
              <span>Title & Link</span>
              <span data-chevron class="ml-2 inline-block transition-transform">›</span>
            </button>
            <div id="taskSelectionLinkBody" class="space-y-2">
              <div>
                <label class="block text-sm font-semibold text-slate-600">Selected Node Title</label>
                <div id="selNodeTitle" contenteditable="true" spellcheck="false" class="text-sm text-slate-800 truncate border rounded px-2 py-1 focus:outline-none focus:ring focus:ring-slate-300">—</div>
              </div>
              <div>
                <label class="block text-sm font-semibold text-slate-600">Link URL</label>
                <input id="selNodeLinkUrl" class="w-full text-sm border rounded px-2 py-1" placeholder="https://example.com" />
                <div class="mt-1 flex items-center gap-2">
                  <label class="inline-flex items-center gap-2 text-xs text-slate-600">
                    <input id="openInNewTab" type="checkbox" class="align-middle">
                    <span>Open in new tab (Ctrl+Click)</span>
                  </label>
                  <p id="linkHint" class="text-xs text-slate-500 hidden">Ctrl+Click node to open</p>
                </div>
              </div>
            </div>
          </div>

          <div id="taskMetadataBlock" class="rounded border p-2 bg-white space-y-2">
            <button id="taskMetadataToggle" type="button" class="w-full text-left font-semibold mb-1 flex items-center justify-between focus:outline-none focus:ring-0 rounded text-sm" aria-expanded="true" aria-controls="taskMetadataBody">
              <span>Metadata</span>
              <span data-chevron class="ml-2 inline-block transition-transform">›</span>
            </button>
            <div id="taskMetadataBody" class="space-y-2">
              <div>
                <label class="block text-sm font-semibold text-slate-600">Translated Title (preview)</label>
                <div class="flex gap-2 items-center">
                  <input id="selNodeTitleTranslated" class="flex-1 text-sm border rounded px-2 py-1" placeholder="—" readonly />
                  <button id="btnRefreshTranslation" class="px-2 py-1 text-xs bg-slate-200 rounded">Refresh</button>
                </div>
              </div>
              <div>
                <label class="block text-sm font-semibold text-slate-600">Selected Node ID</label>
                <div id="selNode" class="text-sm font-mono text-slate-800">—</div>
              </div>
              <div>
                <label class="block text-sm font-semibold text-slate-600">Created At</label>
                <div id="createdAt" class="text-sm text-slate-800">—</div>
              </div>
              <div>
                <label class="block text-sm font-semibold text-slate-600">Descendants (via edges)</label>
                <div id="descCount" class="text-sm text-slate-800">0</div>
              </div>
            </div>
          </div>

          <div id="taskStatusPriorityBlock" class="rounded border p-2 bg-white space-y-2">
            <button id="taskStatusPriorityToggle" type="button" class="w-full text-left font-semibold mb-1 flex items-center justify-between focus:outline-none focus:ring-0 rounded text-sm" aria-expanded="true" aria-controls="taskStatusPriorityBody">
              <span>Status & Priority</span>
              <span data-chevron class="ml-2 inline-block transition-transform">›</span>
            </button>
            <div id="taskStatusPriorityBody" class="space-y-2">
              <div>
                <label class="block text-sm font-semibold">Status</label>
                <div id="statusRadios" role="radiogroup" class="grid grid-cols-3 md:grid-cols-5 gap-1.5">
                  <button type="button" role="radio" aria-checked="false" data-value="planned" class="px-2 py-1 text-xs rounded w-full bg-slate-100 text-slate-800">todo</button>
                  <button type="button" role="radio" aria-checked="false" data-value="in-progress" class="px-2 py-1 text-xs rounded w-full bg-slate-100 text-slate-800">in-progress</button>
                  <button type="button" role="radio" aria-checked="false" data-value="discuss" class="px-2 py-1 text-xs rounded w-full bg-slate-100 text-slate-800">discuss</button>
                  <button type="button" role="radio" aria-checked="false" data-value="done" class="px-2 py-1 text-xs rounded w-full bg-slate-100 text-slate-800">done</button>
                  <button type="button" role="radio" aria-checked="false" data-value="blocked" class="px-2 py-1 text-xs rounded w-full bg-slate-100 text-slate-800">blocked</button>
                </div>
              </div>
              <div>
                <label class="block text-sm font-semibold">Priority</label>
                <div id="priorityRadios" role="radiogroup" class="grid grid-cols-2 md:grid-cols-4 gap-1.5">
                  <button type="button" role="radio" aria-checked="false" data-value="low" class="px-2 py-1 text-xs rounded w-full bg-slate-100 text-slate-800">low</button>
                  <button type="button" role="radio" aria-checked="false" data-value="normal" class="px-2 py-1 text-xs rounded w-full bg-slate-100 text-slate-800">normal</button>
                  <button type="button" role="radio" aria-checked="false" data-value="high" class="px-2 py-1 text-xs rounded w-full bg-slate-100 text-slate-800">high</button>
                  <button type="button" role="radio" aria-checked="false" data-value="critical" class="px-2 py-1 text-xs rounded w-full bg-slate-100 text-slate-800">critical</button>
                </div>
              </div>
            </div>
          </div>

          <div id="taskVisibilityBlock" class="rounded border p-2 bg-white space-y-2">
            <button id="taskVisibilityToggle" type="button" class="w-full text-left font-semibold mb-1 flex items-center justify-between focus:outline-none focus:ring-0 rounded text-sm" aria-expanded="true" aria-controls="taskVisibilityBody">
              <span>Visibility & Metrics</span>
              <span data-chevron class="ml-2 inline-block transition-transform">›</span>
            </button>
            <div id="taskVisibilityBody" class="space-y-2">
              <label class="inline-flex items-center gap-2 text-sm text-slate-700">
                <input id="hideFromBoard" type="checkbox" class="align-middle">
                <span>Hide from board</span>
              </label>
              <div>
                <label class="block text-sm font-semibold text-slate-600">Descendants (via edges)</label>
                <div id="descCount" class="text-sm text-slate-800">0</div>
              </div>
            </div>
          </div>

          <div id="taskCommentsBlock" class="rounded border p-2 bg-white space-y-2">
            <button id="taskCommentsToggle" type="button" class="w-full text-left font-semibold mb-1 flex items-center justify-between focus:outline-none focus:ring-0 rounded text-sm" aria-expanded="true" aria-controls="taskCommentsBody">
              <span>Comments</span>
              <span data-chevron class="ml-2 inline-block transition-transform">›</span>
            </button>
            <div id="taskCommentsBody" class="space-y-2 flex flex-col overflow-hidden" style="--commentsHeight: 32vh; height: clamp(20vh, var(--commentsHeight), 80vh);">
              <div id="taskCommentsResizerTop" role="separator" aria-orientation="horizontal" tabindex="0" class="h-2 cursor-row-resize bg-slate-200 rounded"></div>
              <div id="taskCommentsControls" class="flex items-center justify-end gap-2">
                <button id="btnCommentsFullscreen" type="button" class="px-2 py-1 text-xs rounded bg-slate-200 text-slate-800">Fullscreen</button>
              </div>
              <div id="taskCommentsContent" class="flex-1 flex flex-col min-h-0">
                <div class="flex-1 min-h-0">
                  <ul id="commentsList" class="text-sm space-y-1 h-full overflow-auto"></ul>
                </div>
                <form id="commentForm" class="space-y-1.5">
                <div>
                  <label class="block text-sm">Comment</label>
                  <div id="commentEditor" class="border rounded">
                    <div id="commentToolbar">
                      <span class="ql-formats">
                        <button class="ql-bold" title="Bold"></button>
                        <button class="ql-italic" title="Italic"></button>
                        <button class="ql-underline" title="Underline"></button>
                        <button class="ql-strike" title="Strike"></button>
                      </span>
                      <span class="ql-formats">
                        <button class="ql-code" title="Code"></button>
                        <button class="ql-blockquote" title="Blockquote"></button>
                      </span>
                      <span class="ql-formats">
                        <button class="ql-list" value="ordered" title="Ordered List"></button>
                        <button class="ql-list" value="bullet" title="Bullet List"></button>
                      </span>
                      <span class="ql-formats">
                        <select class="ql-header">
                          <option value="1"></option>
                          <option value="2"></option>
                          <option value="3"></option>
                          <option selected></option>
                        </select>
                      </span>
                      <span class="ql-formats">
                        <button class="ql-link" title="Link"></button>
                        <button class="ql-clean" title="Clear Formatting"></button>
                      </span>
                    </div>
                    <div id="commentEditorArea" class="h-24"></div>
                  </div>
                  <textarea name="body" class="w-full border rounded p-2 hidden" rows="3" placeholder="Write a comment"></textarea>
                </div>
                <input type="hidden" name="user_id" value="system-user" />
                <button type="submit" class="px-3 py-1 bg-blue-600 text-white rounded">Add Comment</button>
                </form>
              </div>
              <div id="taskCommentsResizer" role="separator" aria-orientation="horizontal" tabindex="0" class="h-2 cursor-row-resize bg-slate-200 rounded"></div>
            </div>
          </div>

          <div id="taskHistoryBlock" class="rounded border p-2 bg-white space-y-2">
            <button id="taskHistoryToggle" type="button" class="w-full text-left font-semibold mb-1 flex items-center justify-between focus:outline-none focus:ring-0 rounded text-sm" aria-expanded="true" aria-controls="taskHistoryBody">
              <span>History</span>
              <span data-chevron class="ml-2 inline-block transition-transform">›</span>
            </button>
            <div id="taskHistoryBody">
              <ul id="statusHistory" class="text-sm space-y-1 max-h-24 overflow-auto"></ul>
            </div>
          </div>

          <div id="taskTimeBlock" class="rounded border p-2 bg-white space-y-2">
            <button id="taskTimeToggle" type="button" class="w-full text-left font-semibold mb-1 flex items-center justify-between focus:outline-none focus:ring-0 rounded text-sm" aria-expanded="true" aria-controls="taskTimeBody">
              <span>Time Tracking</span>
              <span data-chevron class="ml-2 inline-block transition-transform">›</span>
            </button>
            <div id="taskTimeBody" class="space-y-1.5">
              <div>
                <ul id="timeList" class="text-sm space-y-1 max-h-24 overflow-auto"></ul>
              </div>
              <form id="timeForm" class="space-y-1.5">
                <div>
                  <label class="block text-sm">Hours</label>
                  <input name="hours" type="number" step="0.1" class="w-full border rounded p-2" placeholder="1.0" />
                </div>
                <input type="hidden" name="user_id" value="system-user" />
                <button type="submit" class="px-3 py-1 bg-emerald-600 text-white rounded">Add Time</button>
              </form>
            </div>
          </div>

          <div id="taskCostsBlock" class="rounded border p-2 bg-white space-y-2">
            <button id="taskCostsToggle" type="button" class="w-full text-left font-semibold mb-1 flex items-center justify-between focus:outline-none focus:ring-0 rounded text-sm" aria-expanded="true" aria-controls="taskCostsBody">
              <span>Costs</span>
              <span data-chevron class="ml-2 inline-block transition-transform">›</span>
            </button>
            <div id="taskCostsBody" class="space-y-1.5">
              <div>
                <ul id="costList" class="text-sm space-y-1 max-h-24 overflow-auto"></ul>
              </div>
              <form id="costForm" class="space-y-1.5">
                <div>
                  <label class="block text-sm">Amount</label>
                  <input name="amount" type="number" step="0.01" class="w-full border rounded p-2" placeholder="100" />
                </div>
                <button type="submit" class="px-3 py-1 bg-amber-600 text-white rounded">Add Cost</button>
              </form>
            </div>
          </div>

          <div id="taskDangerBlock" class="rounded border p-2 bg-white space-y-2">
            <button id="taskDangerToggle" type="button" class="w-full text-left font-semibold mb-1 flex items-center justify-between focus:outline-none focus:ring-0 rounded text-sm" aria-expanded="true" aria-controls="taskDangerBody">
              <span>Danger Zone</span>
              <span data-chevron class="ml-2 inline-block transition-transform">›</span>
            </button>
            <div id="taskDangerBody">
              <button id="btnDeleteNodePanel" class="w-full mt-1 px-3 py-2 bg-rose-600 text-white rounded hidden">Delete Node</button>
            </div>
          </div>

          </div>

          <div id="actionsPanel" class="space-y-3 hidden">
            <div id="actionsMainBlock" class="rounded border p-2 bg-white space-y-2">
              <h3 class="font-medium text-sm">Actions</h3>
              <div class="flex flex-wrap gap-2">
                <button id="btnAddNodePanel" class="px-2 py-1 text-xs rounded bg-blue-600 text-white" title="Add node" aria-label="Add node">+ Node</button>
                <button id="btnAddEdgePanel" class="px-2 py-1 text-xs rounded bg-indigo-600 text-white" title="Add edge" aria-label="Add edge">+ Edge</button>
                <button id="btnCriticalPathPanel" class="px-2 py-1 text-xs rounded bg-teal-600 text-white" title="Critical path" aria-label="Critical path">Critical Path</button>
                <button id="btnFitPanel" class="px-2 py-1 text-xs rounded bg-slate-600 text-white" title="Fit graph" aria-label="Fit graph">Fit</button>
                <button id="btnResetViewPanel" class="px-2 py-1 text-xs rounded bg-slate-200 text-slate-800" title="Reset view" aria-label="Reset view">Reset View</button>
                <button id="btnGroupPanel" class="px-2 py-1 text-xs rounded bg-purple-600 text-white" title="Group selected" aria-label="Group selected">Group</button>
                <button id="btnUngroupPanel" class="px-2 py-1 text-xs rounded bg-purple-500 text-white" title="Ungroup selected" aria-label="Ungroup selected">Ungroup</button>
                <button id="btnCollapsePanel" class="px-2 py-1 text-xs rounded bg-fuchsia-600 text-white" title="Collapse group" aria-label="Collapse group">Collapse</button>
                <button id="btnExpandPanel" class="px-2 py-1 text-xs rounded bg-fuchsia-500 text-white" title="Expand group" aria-label="Expand group">Expand</button>
                <button id="btnScreenshotPanel" class="px-2 py-1 text-xs rounded bg-slate-700 text-white" title="Screenshot" aria-label="Screenshot">Screenshot</button>
              </div>
              <div class="flex items-center justify-end pt-1">
                <button id="btnActionsResetVisibility" class="px-2 py-1 text-xs rounded bg-slate-200 text-slate-800" title="Reset header visibility to defaults" aria-label="Reset header visibility to defaults">Reset to defaults</button>
              </div>
            </div>
          </div>

          <div id="settingsPanel" class="space-y-3 hidden">
            <div class="flex items-center justify-between">
              <h3 class="font-medium">Settings</h3>
              <div class="flex items-center gap-2">
              </div>
            </div>
            <div id="lodBlock" class="rounded border p-3 bg-white space-y-2">
              <button id="zoomToggle" type="button" class="w-full text-left font-semibold mb-2 flex items-center justify-between focus:outline-none focus:ring-0 rounded" aria-expanded="true" aria-controls="zoomBody">
                <span>Zoom</span>
                <span data-chevron class="ml-2 inline-block transition-transform">›</span>
              </button>
              <div id="zoomBody">
                <label class="inline-flex items-center gap-2">
                  <input id="lodToggle" type="checkbox" class="align-middle">
                  <span>Performance LOD (improve large graph zoom)</span>
                </label>
                <p class="text-xs text-slate-500">When enabled, low-importance nodes may fade/hide at low zoom to keep the view responsive. Disable to always show all nodes.</p>
              </div>
            </div>
            <div id="serverInfo" class="rounded border p-3 text-sm bg-white">
              <button id="serverInfoToggle" type="button" class="w-full text-left font-semibold mb-2 flex items-center justify-between focus:outline-none focus:ring-0 rounded" aria-expanded="true" aria-controls="serverInfoBody">
                <span>Server Info</span>
                <span data-chevron class="ml-2 inline-block transition-transform">›</span>
              </button>
              <div id="serverInfoBody" class="grid grid-cols-2 gap-2">
                <div class="server-info-row">PID: <span id="server-pid">—</span></div>
                <div class="server-info-row">Uptime: <span id="server-uptime">—</span></div>
                <div class="server-info-row">Started: <span id="server-start-time">—</span></div>
                <div class="server-info-row">Current: <span id="server-current-time">—</span></div>
                <div class="server-info-row col-span-2">Last Restart: <span id="server-last-restart">—</span></div>
                <div class="server-info-row col-span-2">
                  <button id="btnRestartInline" class="px-3 py-1 text-xs rounded bg-rose-600 text-white">Restart Server</button>
                </div>
                <div class="server-info-row col-span-2">
                  <a href="https://github.com/elimS2" target="_blank" class="inline-flex items-center gap-2 text-blue-600 hover:underline">
                    <span class="github-text">GitHub: elimS2</span>
                    <img class="github-avatar rounded-full" src="https://github.com/elimS2.png?size=50" alt="elimS2 avatar" width="25" height="25" loading="lazy" decoding="async" referrerpolicy="no-referrer" onerror="this.style.display='none'">
                  </a>
                </div>
              </div>
            </div>
            <div id="envBlock" class="rounded border p-3 bg-white space-y-2">
              <button id="envToggle" type="button" class="w-full text-left font-semibold flex items-center justify-between focus:outline-none focus:ring-0 rounded" aria-expanded="true" aria-controls="envBody">
                <span>.env</span>
                <span class="inline-flex items-center gap-2">
                  <span id="settingsSource" class="text-xs text-slate-500"></span>
                  <span data-chevron class="ml-2 inline-block transition-transform">›</span>
                </span>
              </button>
              <div id="envBody">
                <input id="settingsFilter" type="text" placeholder="Filter by key..." class="w-full border rounded px-2 py-1" />
                <div id="settingsFallbackAlert" class="hidden text-sm text-amber-800 bg-amber-50 border border-amber-200 rounded p-2"></div>
                <div class="overflow-auto rounded border">
                  <table class="min-w-full text-sm">
                    <thead class="bg-slate-100 text-slate-700">
                      <tr>
                        <th class="text-left px-3 py-2 font-medium">Key</th>
                        <th class="text-left px-3 py-2 font-medium">Value</th>
                        <th class="text-left px-3 py-2 font-medium">Actions</th>
                      </tr>
                    </thead>
                    <tbody id="settingsTable" class="divide-y"></tbody>
                  </table>
                </div>
              </div>
            </div>

            <div id="exportImportBlock" class="rounded border p-3 bg-white space-y-2">
              <button id="exportImportToggle" type="button" class="w-full text-left font-semibold mb-2 flex items-center justify-between focus:outline-none focus:ring-0 rounded" aria-expanded="true" aria-controls="exportImportBody">
                <span>Export-Import JSON</span>
                <span data-chevron class="ml-2 inline-block transition-transform">›</span>
              </button>
              <div id="exportImportBody">
                <div class="flex flex-wrap gap-2">
                  <button id="settingsBtnExportJSON" class="px-3 py-1 bg-slate-700 text-white rounded" aria-label="Export project as JSON" title="Export project as JSON">Export JSON</button>
                  <label class="px-3 py-1 bg-slate-700 text-white rounded cursor-pointer" aria-label="Import project from JSON" title="Import project from JSON">Import JSON
                    <input id="settingsImportInput" type="file" accept="application/json" class="hidden" />
                  </label>
                </div>
                <p class="text-xs text-slate-500">Export current graph to a JSON file or import nodes from a JSON file. Import appends nodes; edges import is not supported here.</p>
              </div>
            </div>

            <div id="visibilityBlock" class="rounded border p-3 bg-white space-y-2">
              <button id="visibilityToggle" type="button" class="w-full text-left font-semibold mb-2 flex items-center justify-between focus:outline-none focus:ring-0 rounded" aria-expanded="true" aria-controls="visibilityBody">
                <span>Visibility</span>
                <span data-chevron class="ml-2 inline-block transition-transform">›</span>
              </button>
              <div id="visibilityBody">
                <label class="inline-flex items-center gap-2 text-sm text-slate-700">
                  <input id="settingsShowHiddenToggle" type="checkbox" class="align-middle">
                  <span>Show hidden</span>
                </label>
                <p class="text-xs text-slate-500 mt-1">When enabled, nodes marked as hidden are included in the board. Hidden nodes appear faint with dashed borders. Disable to fully hide them from the graph and lists.</p>
              </div>
            </div>

            <div id="translationBlock" class="rounded border p-3 bg-white space-y-3">
              <button id="translationToggle" type="button" class="w-full text-left font-semibold mb-2 flex items-center justify-between focus:outline-none focus:ring-0 rounded" aria-expanded="true" aria-controls="translationBody">
                <span>Translation</span>
                <span data-chevron class="ml-2 inline-block transition-transform">›</span>
              </button>
              <div id="translationBody">
                <div class="flex items-center gap-3 flex-wrap">
                  <label class="text-sm text-slate-700">Language
                    <select id="settingsLangSelect" class="ml-2 border rounded px-2 py-1">
                      <option value="">Original</option>
                      <option value="en">English</option>
                    </select>
                  </label>
                  <button id="settingsBtnTrStats" class="px-3 py-1 bg-slate-200 text-slate-800 rounded" aria-label="Show translation stats" title="Show translation stats">Translation Stats</button>
                  <button id="settingsBtnRunTranslate" class="px-3 py-1 bg-indigo-600 text-white rounded" aria-label="Run translation job" title="Run translation job">Run Translate</button>
                </div>
                <div id="settingsTranslationFeedback" class="text-xs text-slate-600 space-y-1">
                  <div id="settingsTrStats" class="whitespace-pre-wrap"></div>
                  <div id="settingsTrJob" class=""></div>
                </div>
              </div>
            </div>
          </div>
        </aside>
      </div>
    </div>

    <script>
      const projectId = "{{ project.id }}";

      function formatDate(iso) {
        if (!iso) return '—';
        const d = new Date(iso);
        if (isNaN(d.getTime())) return String(iso);
        try {
          const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
          const base = new Intl.DateTimeFormat(navigator.language || 'en-US', {
            year: 'numeric', month: 'short', day: '2-digit',
            hour: '2-digit', minute: '2-digit', hour12: false,
            timeZoneName: 'short'
          }).format(d);
          return `${base} (${tz})`;
        } catch { return d.toLocaleString(); }
      }

      // Toast notifications
      function showToast(message, type = 'info'){
        try {
          let cont = document.getElementById('toastContainer');
          if (!cont){
            cont = document.createElement('div');
            cont.id = 'toastContainer';
            cont.className = 'fixed top-3 left-1/2 -translate-x-1/2 z-[9999] space-y-2';
            cont.setAttribute('role','status');
            cont.setAttribute('aria-live','polite');
            document.body.appendChild(cont);
          }
          const base = 'px-3 py-2 rounded shadow border text-sm';
          const color = type === 'success' ? 'bg-emerald-100 text-emerald-800 border-emerald-200'
                        : type === 'error' ? 'bg-rose-100 text-rose-800 border-rose-200'
                        : 'bg-sky-100 text-sky-800 border-sky-200';
          const el = document.createElement('div');
          el.className = `${base} ${color}`;
          el.textContent = String(message || '');
          cont.appendChild(el);
          setTimeout(()=>{ try { el.style.transition = 'opacity 200ms'; el.style.opacity = '0'; setTimeout(()=>{ el.remove(); }, 220); } catch {} }, 2200);
        } catch {}
      }

      // Preferences helpers
      function getCurrentLang(){
        try {
          const s = document.getElementById('settingsLangSelect');
          return (s && s.value) || localStorage.getItem('displayLang') || '';
        } catch { return localStorage.getItem('displayLang') || ''; }
      }
      function isShowHiddenEnabled(){
        // Prefer persisted value when available to avoid race with late checkbox wiring
        try {
          const persisted = localStorage.getItem('showHidden');
          if (persisted === '1') return true;
          if (persisted === '0') return false;
        } catch {}
        try {
          const s = document.getElementById('settingsShowHiddenToggle');
          if (s) return !!s.checked;
        } catch {}
        return false;
      }

      async function apiMe(){
        const r = await fetch('/api/v1/auth/me');
        const j = await r.json();
        return j && j.data;
      }
      async function apiLogin(email, password){
        const r = await fetch('/api/v1/auth/login', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({email, password})});
        if (!r.ok) throw new Error('Login failed');
        return r.json();
      }
      async function apiLogout(){ await fetch('/api/v1/auth/logout', {method:'POST'}); }

      // LOD preference helpers (persisted in localStorage)
      function getLodEnabled(){
        return localStorage.getItem('lodEnabled') !== '0';
      }
      function setLodEnabled(enabled){
        localStorage.setItem('lodEnabled', enabled ? '1' : '0');
      }

      // Sidebar reorder helpers (top-level)
      const ORDER_KEYS = { task: 'sidebar.task.order', settings: 'sidebar.settings.order' };
      const DEFAULT_TASK_IDS = ['taskSelectionLinkBlock','taskMetadataBlock','taskStatusPriorityBlock','taskVisibilityBlock','taskCommentsBlock','taskHistoryBlock','taskTimeBlock','taskCostsBlock','taskDangerBlock'];
      const DEFAULT_SETTINGS_IDS = ['lodBlock','serverInfo','envBlock','exportImportBlock','visibilityBlock','translationBlock'];
      function loadOrder(key){ try { return JSON.parse(localStorage.getItem(key) || '[]'); } catch { return []; } }
      function saveOrder(key, ids){ try { localStorage.setItem(key, JSON.stringify(ids || [])); } catch {} }
      function applyPanelOrder(panelEl, storageKey, defaultIds){
        try {
          if (!panelEl) return;
          const saved = Array.isArray(loadOrder(storageKey)) ? loadOrder(storageKey) : [];
          const allowed = new Set(defaultIds);
          const filteredSaved = saved.filter(id => allowed.has(id));
          const missing = defaultIds.filter(id => !filteredSaved.includes(id));
          const finalOrder = [...filteredSaved, ...missing];
          finalOrder.forEach(id=>{
            const el = document.getElementById(id);
            if (el && el.parentElement === panelEl){ panelEl.appendChild(el); }
          });
        } catch {}
      }
      function getPanelIds(panelEl, defaultIds){
        try {
          const ids = [];
          defaultIds.forEach(id => {
            const el = document.getElementById(id);
            if (el && el.parentElement === panelEl) ids.push(id);
          });
          return ids;
        } catch { return []; }
      }
      function wireReorderablePanel(panelEl, storageKey, defaultIds){
        try {
          if (!panelEl || panelEl.dataset.reorderWired === '1') return;
          panelEl.dataset.reorderWired = '1';
          const allowed = new Set(defaultIds);
          // Inject drag handles and set draggable on blocks
          defaultIds.forEach(id=>{
            const block = document.getElementById(id);
            if (!block || block.parentElement !== panelEl) return;
            block.setAttribute('data-panel-block','1');
            const headerBtn = block.querySelector('button[id$="Toggle"]');
            if (headerBtn && !headerBtn.querySelector('[data-drag-handle]')){
              const handle = document.createElement('span');
              handle.setAttribute('data-drag-handle','1');
              handle.setAttribute('title','Reorder section');
              handle.setAttribute('draggable','true');
              handle.className = 'ml-2 text-slate-400 hover:text-slate-600 cursor-grab select-none';
              handle.textContent = '⋮⋮';
              // prevent header click/collapse when starting drag from handle
              handle.addEventListener('mousedown', (e)=>{ e.stopPropagation(); });
              handle.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); });
              headerBtn.appendChild(handle);
            }
          });
          const state = { draggingId: null, placeholder: null };
          panelEl.addEventListener('dragstart', (e)=>{
            const src = e.target && e.target.closest ? e.target.closest('[data-panel-block]') : null;
            if (!src || src.parentElement !== panelEl || !allowed.has(src.id)){ e.preventDefault(); return; }
            state.draggingId = src.id;
            src.classList.add('opacity-60');
            const ph = document.createElement('div');
            ph.className = 'border-2 border-dashed border-slate-300 rounded my-1';
            ph.style.height = src.offsetHeight + 'px';
            state.placeholder = ph;
            src.after(ph);
            e.dataTransfer.effectAllowed = 'move';
            try { e.dataTransfer.setData('text/plain', src.id); } catch {}
          });
          panelEl.addEventListener('dragover', (e)=>{
            if (!state.draggingId) return;
            e.preventDefault();
            let target = e.target && e.target.closest ? e.target.closest('[data-panel-block]') : null;
            if (!target) return;
            // Ensure we target the top-level block inside this panel
            while (target && (target.parentElement !== panelEl || !allowed.has(target.id))) {
              target = target.parentElement;
            }
            if (!target || target.id === state.draggingId) return;
            const rect = target.getBoundingClientRect();
            const before = (e.clientY - rect.top) < rect.height / 2;
            if (state.placeholder){
              if (before) { target.before(state.placeholder); }
              else { target.after(state.placeholder); }
            }
          });
          panelEl.addEventListener('drop', (e)=>{
            if (!state.draggingId || !state.placeholder) return;
            e.preventDefault();
            const dragged = document.getElementById(state.draggingId);
            if (dragged && state.placeholder.parentElement === panelEl){
              state.placeholder.replaceWith(dragged);
              const ids = getPanelIds(panelEl, defaultIds);
              saveOrder(storageKey, ids);
            }
            if (dragged) dragged.classList.remove('opacity-60');
            state.draggingId = null;
            state.placeholder = null;
          });
          panelEl.addEventListener('dragend', ()=>{
            const dragged = state.draggingId ? document.getElementById(state.draggingId) : null;
            if (dragged) dragged.classList.remove('opacity-60');
            if (state.placeholder) { try { state.placeholder.remove(); } catch {} }
            state.draggingId = null;
            state.placeholder = null;
          });
        } catch {}
      }

      function wireAuthHeader(){
        const emailEl = document.getElementById('userEmail');
        const btnLogin = document.getElementById('btnLogin');
        const btnLogout = document.getElementById('btnLogout');
        async function refresh(){
          const me = await apiMe();
          if (me && me.id){
            emailEl.textContent = me.id;
            emailEl.classList.remove('hidden');
            btnLogout.classList.remove('hidden');
            btnLogin.classList.add('hidden');
          } else {
            emailEl.classList.add('hidden');
            btnLogout.classList.add('hidden');
            btnLogin.classList.remove('hidden');
          }
        }
        btnLogin.addEventListener('click', async ()=>{
          const email = prompt('Email');
          const password = prompt('Password');
          if (!email || !password) return;
          try { await apiLogin(email, password); } catch { alert('Invalid credentials'); }
          refresh();
        });
        btnLogout.addEventListener('click', async ()=>{ await apiLogout(); refresh(); });
        refresh();
      }

      async function fetchGraph(lang="") {
        const showHidden = isShowHiddenEnabled();
        const params = new URLSearchParams();
        const effLang = lang || getCurrentLang();
        if (effLang) params.set('lang', effLang);
        if (showHidden) params.set('include_hidden', '1');
        const q = params.toString() ? `?${params.toString()}` : "";
        const [nodesRes, edgesRes] = await Promise.all([
          fetch(`/api/v1/projects/${projectId}/nodes${q}`),
          fetch(`/api/v1/projects/${projectId}/edges`),
        ]);
        const nodesJson = await nodesRes.json();
        const edgesJson = await edgesRes.json();
        return { nodes: nodesJson.data, edges: edgesJson.data };
      }

      function toElements(graph) {
        const dotIcon = 'data:image/svg+xml;utf8,' + encodeURIComponent(
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">\
            <circle cx="25" cy="25" r="12" fill="#0f172a"/>\
            <circle cx="75" cy="25" r="12" fill="#0f172a"/>\
            <circle cx="25" cy="75" r="12" fill="#0f172a"/>\
            <circle cx="75" cy="75" r="12" fill="#0f172a"/>\
            <circle cx="50" cy="50" r="12" fill="#0f172a"/>\
          </svg>'
        );
        const nodes = graph.nodes.map(n => {
          const data = {
            id: String(n.id),
            label: (n.title_translated || n.title),
            score: n.importance_score,
            status: n.status,
            is_group: !!n.is_group,
            parent: (n.parent_id !== null && n.parent_id !== undefined) ? String(n.parent_id) : undefined,
            dotIcon: dotIcon,
            savedX: (n.position && typeof n.position.x === 'number') ? n.position.x : null,
            savedY: (n.position && typeof n.position.y === 'number') ? n.position.y : null,
            created_at: n.created_at,
            priority: (n.priority || 'normal'),
            descendants: 0
          };
          const link = (typeof n.link_url === 'string') ? n.link_url.trim() : '';
          if (link) { data.link_url = link; }
          // propagate per-node open preference
          if (typeof n.link_open_in_new_tab === 'boolean') { data.link_open_in_new_tab = !!n.link_open_in_new_tab; }
          if (typeof n.is_hidden === 'boolean') { data.is_hidden = !!n.is_hidden; }
          return ({ data, position: n.position });
        });
        const prioById = new Map(nodes.map(ne => [ne.data.id, ne.data.priority]));
        const statusById = new Map(nodes.map(ne => [ne.data.id, ne.data.status]));
        const nodeIds = new Set(nodes.map(ne => ne.data.id));
        const edges = graph.edges
          .filter(e => nodeIds.has(String(e.source_node_id)) && nodeIds.has(String(e.target_node_id)))
          .map(e => ({ data: { id: String(e.id), source: String(e.source_node_id), target: String(e.target_node_id), type: e.type, weight: e.weight, targetPriority: prioById.get(String(e.target_node_id)) || 'normal', targetStatus: statusById.get(String(e.target_node_id)) || 'planned', pathPriority: 'none' }}));
        // compute descendants counts on client (outgoing reachability) and priority paths
        const idToNode = new Map();
        nodes.forEach(n => idToNode.set(n.data.id, n));
        const adj = new Map();
        nodes.forEach(n => adj.set(n.data.id, []));
        graph.edges.forEach(e => { const a = adj.get(String(e.source_node_id)); if (a) a.push(String(e.target_node_id)); });
        function countDesc(start){
          const visited = new Set([start]);
          const q = [start];
          let c = 0;
          while (q.length){
            const cur = q.shift();
            (adj.get(cur) || []).forEach(t => { if (!visited.has(t)) { visited.add(t); q.push(t); c++; } });
          }
          return c;
        }
        nodes.forEach(n => { n.data.descendants = countDesc(n.data.id); });
        // Compute lightweight LOD score for each node for zoom-level filtering
        // lod_score combines normalized degree and descendants to approximate importance
        const indegree = new Map();
        nodes.forEach(n => indegree.set(n.data.id, 0));
        graph.edges.forEach(e => {
          const tgt = String(e.target_node_id);
          if (indegree.has(tgt)) indegree.set(tgt, (indegree.get(tgt) || 0) + 1);
        });
        let maxDegree = 0;
        let maxDescendants = 0;
        const degreeById = new Map();
        nodes.forEach(n => {
          const out = (adj.get(n.data.id) || []).length;
          const inn = indegree.get(n.data.id) || 0;
          const deg = out + inn;
          degreeById.set(n.data.id, deg);
          if (deg > maxDegree) maxDegree = deg;
          if (n.data.descendants > maxDescendants) maxDescendants = n.data.descendants;
        });
        nodes.forEach(n => {
          const deg = degreeById.get(n.data.id) || 0;
          const normDeg = maxDegree > 0 ? (deg / maxDegree) : 0;
          const normDesc = maxDescendants > 0 ? (n.data.descendants / maxDescendants) : 0;
          const lodScore = (0.6 * normDeg) + (0.4 * normDesc);
          n.data.lod_score = Number(lodScore.toFixed(4));
        });
        // mark edges on any path to high/critical (not done) targets
        const incoming = new Map(); nodes.forEach(n=>incoming.set(n.data.id, []));
        graph.edges.forEach(e => { (incoming.get(String(e.target_node_id))||[]).push(String(e.source_node_id)); });
        const pathPrio = new Map(graph.edges.map(e=>[String(e.id), 'none']));
        const queue = [];
        nodes.forEach(n => {
          const pr = n.data.priority || 'normal';
          const st = n.data.status || 'planned';
          if ((pr==='high' || pr==='critical') && st!=='done') queue.push(n.data.id);
        });
        while (queue.length){
          const tgt = queue.shift();
          const preds = incoming.get(tgt) || [];
          preds.forEach(src => {
            const edge = graph.edges.find(e => String(e.source_node_id)===src && String(e.target_node_id)===tgt);
            if (edge){
              const pr = prioById.get(tgt) || 'normal';
              const key = String(edge.id);
              const desired = (pr==='critical') ? 'critical' : (pr==='high' ? 'high' : 'none');
              if (desired!=='none' && pathPrio.get(key)!==desired){
                pathPrio.set(key, desired);
                queue.push(src);
              }
            }
          });
        }
        edges.forEach(e => { e.data.pathPriority = pathPrio.get(e.data.id) || 'none'; });
        return [...nodes, ...edges];
      }

      (async function init() {
        wireAuthHeader();
        const savedLang = localStorage.getItem('displayLang') || '';
        let graph = await fetchGraph(savedLang);
        const allHavePositions = Array.isArray(graph.nodes) && graph.nodes.length > 0 && graph.nodes.every(n => n.position && typeof n.position.x === 'number' && typeof n.position.y === 'number');
        const cy = cytoscape({
          container: document.getElementById('cy'),
          elements: toElements(graph),
          style: [
            { selector: 'node', style: { 'label': 'data(label)', 'text-valign': 'center', 'color': '#0f172a', 'background-color': '#38bdf8', 'width': 'mapData(descendants, 0, 20, 20, 80)', 'height': 'mapData(descendants, 0, 20, 20, 80)'} },
            { selector: 'node[link_url]', style: { 'color': '#1d4ed8' } },
            { selector: 'edge', style: { 'line-color': '#64748b', 'width': 1.5, 'curve-style': 'bezier', 'target-arrow-color': '#64748b', 'target-arrow-shape': 'triangle', 'arrow-scale': 1.2 } },
            { selector: 'edge[pathPriority = "high"]', style: { 'line-color': '#f59e0b', 'target-arrow-color': '#f59e0b' } },
            { selector: 'edge[pathPriority = "critical"]', style: { 'line-color': '#ef4444', 'target-arrow-color': '#ef4444' } },
            { selector: 'edge[targetPriority = "high"][targetStatus != "done"]', style: { 'line-color': '#f59e0b', 'target-arrow-color': '#f59e0b' } },
            { selector: 'edge[targetPriority = "critical"][targetStatus != "done"]', style: { 'line-color': '#ef4444', 'target-arrow-color': '#ef4444' } },
            { selector: 'node[?is_hidden]', style: { 'opacity': 0.35, 'border-style': 'dashed', 'border-width': 2, 'border-color': '#64748b' } },
            /* Cytoscape doesn't support :hover selector here; remove to avoid errors */
            /* { selector: 'edge:hover', style: { 'line-color': '#334155', 'target-arrow-color': '#334155', 'width': 2.5, 'arrow-scale': 1.5 } }, */
            { selector: 'edge:selected', style: { 'line-color': '#0ea5e9', 'target-arrow-color': '#0ea5e9', 'width': 2.5, 'arrow-scale': 1.5 } },
            { selector: 'node[status = "planned"]', style: { 'background-color': '#38bdf8' } },
            { selector: 'node[status = "done"]', style: { 'background-color': '#22c55e' } },
            { selector: 'node[status = "in-progress"]', style: { 'background-color': '#f59e0b' } },
            { selector: 'node[status = "discuss"]', style: { 'background-color': '#8b5cf6' } },
            { selector: 'node[status = "blocked"]', style: { 'background-color': '#ef4444' } },
            { selector: '.cp', style: { 'border-width': 4, 'border-color': '#14b8a6' } },
            { selector: 'node[?is_group]', style: {
                'shape': 'ellipse',
                'width': 'mapData(score, 0, 10, 28, 68)',
                'height': 'mapData(score, 0, 10, 28, 68)',
                'border-width': 0,
                'border-color': '#0f172a',
                'border-opacity': 0,
                'background-opacity': 0,
                'background-color': 'transparent'
              }
            },
            { selector: 'node.collapsed', style: {
                'background-image': 'data(dotIcon)',
                'background-fit': 'contain',
                'background-width': '65%',
                'background-height': '65%',
                'background-position-x': '50%',
                'background-position-y': '50%',
                'background-repeat': 'no-repeat'
              }
            },
          ],
          layout: { name: allHavePositions ? 'preset' : 'preset' }
        });
        cy.fit();

        // Recompute priority-based path coloring on current graph
        function recomputePriorityPaths(){
          const rank = (p) => (p==='critical'?2:(p==='high'?1:0));
          // node state: highest priority reachable downstream from this node (including its own if not done)
          const nodeState = new Map();
          cy.nodes().forEach(n=>nodeState.set(n.id(), 0));
          // seed nodes: those with priority high/critical and not done
          const seeds = [];
          cy.nodes().forEach(n=>{
            const status = String(n.data('status')||'planned');
            if (status !== 'done'){
              const pr = String(n.data('priority')||'normal');
              const r = rank(pr);
              if (r>0){ nodeState.set(n.id(), r); seeds.push(n.id()); }
            }
          });
          cy.edges().forEach(e=>e.data('pathPriority','none'));
          // reverse BFS propagation
          const queue = [...seeds];
          while(queue.length){
            const tgtId = queue.shift();
            const tgtRank = nodeState.get(tgtId)||0;
            cy.edges(`[target = "${tgtId}"]`).forEach(e=>{
              // set edge path priority
              if (tgtRank===2) e.data('pathPriority','critical');
              else if (tgtRank===1) e.data('pathPriority','high');
              // propagate to source node
              const srcId = String(e.data('source'));
              const cur = nodeState.get(srcId)||0;
              if (tgtRank>cur){ nodeState.set(srcId, tgtRank); queue.push(srcId); }
            });
          }
        }
        // Keep edge data flags in sync with target node's status/priority for direct selectors
        function refreshEdgeTargetFlags(nodeId){
          const nid = String(nodeId || '');
          if (!nid) return;
          const n = cy.getElementById(nid);
          if (!n || !n.nonempty()) return;
          const status = String(n.data('status') || 'planned');
          const priority = String(n.data('priority') || 'normal');
          cy.edges(`[target = "${nid}"]`).forEach(e => {
            e.data('targetStatus', status);
            e.data('targetPriority', priority);
          });
        }
        // initial compute
        recomputePriorityPaths();

        function applyInitialPositions() {
          // Set saved positions for nodes that have them
          cy.nodes().forEach(n => {
            const x = n.data('savedX');
            const y = n.data('savedY');
            if (typeof x === 'number' && typeof y === 'number') {
              n.position({ x, y });
            }
          });
          // Layout only nodes without saved positions
          const needLayout = cy.nodes().filter(n => !(typeof n.data('savedX') === 'number' && typeof n.data('savedY') === 'number'));
          if (needLayout.length > 0) {
            needLayout.layout({ name: 'cose' }).run();
          }
        }
        applyInitialPositions();

        // WYSIWYG comment editor (Quill)
        let quill = null;
        // Inline editor for existing comments
        let quillEdit = null;
        let currentUserId = null;
        function initQuillOnce(){
          if (quill) return;
          try {
            const toolbar = document.getElementById('commentToolbar');
            const area = document.getElementById('commentEditorArea');
            if (!toolbar || !area || !(window.Quill)) return;
            quill = new Quill('#commentEditorArea', {
              modules: { toolbar: '#commentToolbar' },
              theme: 'snow',
              placeholder: 'Write a comment',
            });
          } catch {}
        }
        async function ensureCurrentUser(){
          if (currentUserId !== null) return currentUserId;
          try { const me = await apiMe(); currentUserId = (me && me.id) ? String(me.id) : null; } catch { currentUserId = null; }
          return currentUserId;
        }
        function destroyQuillEdit(){ try { if (quillEdit) { quillEdit.disable(); quillEdit = null; } } catch {} }

        const selEl = document.getElementById('selNode');
        let selectedNodeId = null;
        const oversizedOpenFiredForNodeIds = new Set();
        let lastOversizeDebugAt = 0;
        const prefetchedOrigins = new Set();
        const prefetchedUrls = new Set();
        const specPrefetchUrls = new Set();
        const specPrerenderUrls = new Set();
        let selectedEdgeId = null;
        async function refreshLists(nodeId) {
          const lang = getCurrentLang();
          const q = lang ? `?lang=${encodeURIComponent(lang)}` : '';
          const [c, t, k] = await Promise.all([
            fetch(`/api/v1/nodes/${nodeId}/comments${q}`).then(r=>r.json()),
            fetch(`/api/v1/nodes/${nodeId}/time-entries`).then(r=>r.json()),
            fetch(`/api/v1/nodes/${nodeId}/cost-entries`).then(r=>r.json()),
          ]);
          await ensureCurrentUser();
          const commentsList = document.getElementById('commentsList');
          commentsList.innerHTML = '';
          c.data.forEach(x => {
            const li = document.createElement('li');
            const body = document.createElement('div');
            if (x.body_html) {
              body.className = 'comments-prose';
              body.innerHTML = x.body_html;
              // Ensure links are safe
              try { body.querySelectorAll('a').forEach(a => { a.setAttribute('rel', 'noopener noreferrer nofollow'); a.setAttribute('target', '_blank'); }); } catch {}
            } else {
              body.textContent = (x.body_translated || x.body);
            }
            const time = document.createElement('span'); time.className = 'ml-2 text-xs text-slate-500'; time.textContent = formatDate(x.created_at);
            li.appendChild(body); li.appendChild(time);

            // Actions for own comments
            if (currentUserId && x.user_id && String(x.user_id) === String(currentUserId)) {
              const actions = document.createElement('div');
              actions.className = 'mt-1 flex gap-2';
              const btnEdit = document.createElement('button'); btnEdit.type = 'button'; btnEdit.className = 'text-xs text-blue-600 underline'; btnEdit.textContent = 'Edit';
              const btnDel = document.createElement('button'); btnDel.type = 'button'; btnDel.className = 'text-xs text-red-600 underline'; btnDel.textContent = 'Delete';
              actions.appendChild(btnEdit); actions.appendChild(btnDel);
              li.appendChild(actions);

              btnEdit.addEventListener('click', () => {
                // Enter edit mode: replace body with inline editor and show Save/Cancel
                try {
                  // Clear body container
                  const editWrap = document.createElement('div');
                  editWrap.className = 'mt-1';
                  const editArea = document.createElement('div');
                  editArea.className = 'border rounded';
                  const editAreaInner = document.createElement('div');
                  editAreaInner.className = 'h-24';
                  editArea.appendChild(editAreaInner);
                  const ctrl = document.createElement('div');
                  ctrl.className = 'mt-1 flex gap-2';
                  const btnSave = document.createElement('button'); btnSave.type = 'button'; btnSave.className = 'px-2 py-1 text-xs rounded bg-blue-600 text-white'; btnSave.textContent = 'Save';
                  const btnCancel = document.createElement('button'); btnCancel.type = 'button'; btnCancel.className = 'px-2 py-1 text-xs rounded bg-slate-200 text-slate-800'; btnCancel.textContent = 'Cancel';
                  ctrl.appendChild(btnSave); ctrl.appendChild(btnCancel);

                  // Hide existing content while editing
                  body.classList.add('hidden');
                  time.classList.add('hidden');
                  actions.classList.add('hidden');
                  li.appendChild(editWrap);
                  editWrap.appendChild(editArea);
                  editWrap.appendChild(ctrl);

                  // Init edit Quill
                  destroyQuillEdit();
                  const toolbarOpts = [
                    ['bold','italic','underline','strike'],
                    [{ 'header': [1,2,3,false] }],
                    [{ 'list': 'ordered' }, { 'list': 'bullet' }, { 'indent': '-1' }, { 'indent': '+1' }],
                    ['blockquote','code-block','link'],
                    ['clean']
                  ];
                  quillEdit = new Quill(editAreaInner, { modules: { toolbar: toolbarOpts }, theme: 'snow', placeholder: 'Edit comment' });
                  if (x.body_html) {
                    quillEdit.root.innerHTML = x.body_html || '';
                  } else {
                    try { quillEdit.setText(String(x.body || '')); } catch {}
                  }

                  btnCancel.addEventListener('click', async () => {
                    destroyQuillEdit();
                    await refreshLists(selectedNodeId);
                  });
                  btnSave.addEventListener('click', async () => {
                    try {
                      let html = quillEdit ? (quillEdit.root.innerHTML || '') : '';
                      let text = quillEdit ? (quillEdit.getText() || '').trim() : '';
                      if (!text) { alert('Comment cannot be empty'); return; }
                      await patchJSON(`/api/v1/comments/${x.id}`, { body: text, body_html: html });
                      destroyQuillEdit();
                      await refreshLists(selectedNodeId);
                    } catch (e) {
                      alert(String(e && e.message ? e.message : 'Failed to update comment'));
                    }
                  });
                } catch {}
              });

              btnDel.addEventListener('click', async () => {
                if (!confirm('Delete this comment?')) return;
                try {
                  await del(`/api/v1/comments/${x.id}`);
                  await refreshLists(selectedNodeId);
                } catch { alert('Failed to delete'); }
              });
            }
            commentsList.appendChild(li);
          });
          const timeList = document.getElementById('timeList');
          timeList.innerHTML = '';
          t.data.forEach(x => {
            const li = document.createElement('li');
            li.textContent = `${x.hours}h`;
            timeList.appendChild(li);
          });
          const costList = document.getElementById('costList');
          costList.innerHTML = '';
          k.data.forEach(x => {
            const li = document.createElement('li');
            const amt = document.createElement('span'); amt.textContent = `${x.amount} ${x.currency || 'USD'}`;
            const when = document.createElement('span'); when.className = 'ml-2 text-xs text-slate-500'; when.textContent = formatDate(x.incurred_at);
            li.appendChild(amt); li.appendChild(when);
            costList.appendChild(li);
          });
          // status history
          try {
            const h = await fetch(`/api/v1/nodes/${nodeId}/status-history`).then(r=>r.json());
            const sh = document.getElementById('statusHistory');
            sh.innerHTML = '';
            (h.data || []).forEach(x => {
              const li = document.createElement('li');
              li.textContent = `${x.old_status} → ${x.new_status}`;
              const when = document.createElement('span'); when.className = 'ml-2 text-xs text-slate-500'; when.textContent = formatDate(x.created_at);
              li.appendChild(when);
              sh.appendChild(li);
            });
          } catch {}
        }

        cy.on('tap', 'node', async (evt) => {
          initQuillOnce();
          // Ctrl+click opens link_url in new tab (if present)
          try {
            const oe = evt.originalEvent;
            const url = evt.target && evt.target.data ? (evt.target.data('link_url') || '') : '';
            if (oe && oe.ctrlKey && url) {
              let openNew = (localStorage.getItem('openLinkInNewTab') !== '0');
              try {
                const nodePref = evt.target.data('link_open_in_new_tab');
                if (typeof nodePref === 'boolean') openNew = nodePref;
              } catch {}
              const target = openNew ? '_blank' : '_self';
              window.open(url, target, openNew ? 'noopener,noreferrer' : undefined);
              return;
            }
          } catch {}
          selectedNodeId = evt.target.data('id');
          try { oversizedOpenFiredForNodeIds.delete(String(selectedNodeId)); } catch {}
          try { checkAndAutoOpenLinkOnOversized(); } catch {}
          try {
            const u = String(evt.target.data('link_url') || '').trim();
            if (u) { prewarmForUrl(u); tryQueuePrerender(u); }
          } catch {}
          selEl.textContent = selectedNodeId;
          const titleEl = document.getElementById('selNodeTitle');
          if (titleEl) titleEl.textContent = String(evt.target.data('label') || '—');
          const linkEl = document.getElementById('selNodeLinkUrl');
          const linkHint = document.getElementById('linkHint');
          const curLink = String(evt.target.data('link_url') || '');
          if (linkEl) linkEl.value = curLink;
          if (linkHint) { if (curLink) linkHint.classList.remove('hidden'); else linkHint.classList.add('hidden'); }
          try {
            const lang = getCurrentLang();
            const out = document.getElementById('selNodeTitleTranslated');
            if (!lang) { if(out) out.value=''; }
            else {
              const r = await fetch(`/api/v1/nodes/${selectedNodeId}/translation?lang=${encodeURIComponent(lang)}`).then(x=>x.json());
              const t = r && r.data && r.data.text;
              if (out) out.value = t || '';
            }
          } catch {}
          const createdEl = document.getElementById('createdAt');
          if (createdEl) createdEl.textContent = formatDate(evt.target.data('created_at'));
          const delBtn = document.getElementById('btnDeleteNodePanel');
          if (delBtn) delBtn.classList.remove('hidden');
          const prGrp = document.getElementById('priorityRadios');
          if (prGrp) setRadioGroupValue(prGrp, String(evt.target.data('priority') || 'normal'));
          // reflect hidden state
          try {
            const hideChk = document.getElementById('hideFromBoard');
            if (hideChk) hideChk.checked = !!evt.target.data('is_hidden');
          } catch {}
          // reflect per-node open target in checkbox (fallback to storage default)
          try {
            const chk = document.getElementById('openInNewTab');
            if (chk) {
              let nodePref = evt.target.data('link_open_in_new_tab');
              if (typeof nodePref !== 'boolean') {
                const saved = localStorage.getItem('openLinkInNewTab');
                nodePref = (saved === null || saved === '1'); // default true
              }
              chk.checked = !!nodePref;
            }
          } catch {}
          // compute descendants via outgoing edges (reachability)
          const start = cy.getElementById(selectedNodeId);
          let count = 0;
          if (start && start.nonempty()) {
            const visited = new Set([start.id()]);
            const queue = [start];
            while (queue.length) {
              const cur = queue.shift();
              const out = cur.outgoers('edge');
              out.targets().forEach(t => {
                if (!visited.has(t.id())) { visited.add(t.id()); queue.push(t); count++; }
              });
            }
          }
          const dc = document.getElementById('descCount');
          if (dc) dc.textContent = String(count);
          selectedEdgeId = null;
          // set status select to node status
          const stGrp = document.getElementById('statusRadios');
          if (stGrp) setRadioGroupValue(stGrp, String(evt.target.data('status') || 'planned'));
          await refreshLists(selectedNodeId);
        });
        cy.on('tap', 'edge', (evt) => {
          selectedEdgeId = evt.target.data('id');
          selectedNodeId = null;
          selEl.textContent = '—';
          const delBtn = document.getElementById('btnDeleteNodePanel');
          if (delBtn) delBtn.classList.add('hidden');
        });

        async function postJSON(url, data) {
          const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) });
          if (res.status === 401) { alert('Login required'); throw new Error('Unauthorized'); }
          if (!res.ok) throw new Error('Request failed');
          return res.json();
        }
        async function patchJSON(url, data) {
          const res = await fetch(url, { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) });
          if (res.status === 401) { alert('Login required'); throw new Error('Unauthorized'); }
          if (!res.ok) {
            let msg = 'Request failed';
            try {
              const j = await res.json();
              const e0 = (j && j.errors && j.errors[0]) || null;
              msg = (e0 && (e0.detail || e0.title)) || msg;
            } catch {
              try { msg = (await res.text()) || msg; } catch {}
            }
            throw new Error(msg);
          }
          return res.json();
        }
        async function del(url) {
          const res = await fetch(url, { method: 'DELETE' });
          if (res.status === 401) { alert('Login required'); throw new Error('Unauthorized'); }
          if (!res.ok && res.status !== 204) throw new Error('Request failed');
        }

        function addNodeToCy(n) {
          const ext = cy.extent();
          const padding = 30;
          const pos = { x: ext.x1 + padding, y: ext.y1 + padding };
          cy.add({ group: 'nodes', data: { id: n.id, label: n.title, score: n.importance_score || 0, status: n.status || 'todo', savedX: pos.x, savedY: pos.y }, position: pos });
          // Persist initial position best-effort
          postJSON(`/api/v1/nodes/${n.id}/position`, { x: pos.x, y: pos.y }).catch(()=>{});
        }
        function addEdgeToCy(e) {
          const tgt = cy.getElementById(String(e.target_node_id));
          const tp = tgt && tgt.nonempty() ? (tgt.data('priority') || 'normal') : 'normal';
          const ts = tgt && tgt.nonempty() ? (tgt.data('status') || 'planned') : 'planned';
          cy.add({ group: 'edges', data: { id: e.id, source: e.source_node_id, target: e.target_node_id, type: e.type, weight: e.weight, targetPriority: tp, targetStatus: ts } });
          // recompute descendants sizes quickly
          const nodes = cy.nodes();
          const adj = new Map();
          nodes.forEach(n => adj.set(n.id(), []));
          cy.edges().forEach(ed => { const a = adj.get(ed.data('source')); if (a) a.push(ed.data('target')); });
          function countDesc(start){ const vis = new Set([start]); const q=[start]; let c=0; while(q.length){ const cur=q.shift(); (adj.get(cur)||[]).forEach(t=>{ if(!vis.has(t)){vis.add(t); q.push(t); c++; } }); } return c; }
          nodes.forEach(n => n.data('descendants', countDesc(n.id())));
          recomputePriorityPaths();
        }

        document.getElementById('commentForm').addEventListener('submit', async (e) => {
          e.preventDefault();
          if (!selectedNodeId) return;
          const fd = new FormData(e.target);
          let html = null;
          let text = String(fd.get('body') || '').trim();
          try {
            if (quill) {
              html = quill.root.innerHTML || '';
              // derive text content (Quill inserts <p><br></p> for empty)
              text = (quill.getText() || '').trim();
              if (!text) html = null; // treat empty as no-op body_html
            }
          } catch {}
          if (!text) return; // do not submit empty
          await postJSON(`/api/v1/nodes/${selectedNodeId}/comments`, { body: text, body_html: html });
          e.target.reset();
          try { if (quill) { quill.setContents([]); } } catch {}
          await refreshLists(selectedNodeId);
        });

        document.getElementById('timeForm').addEventListener('submit', async (e) => {
          e.preventDefault();
          if (!selectedNodeId) return;
          const fd = new FormData(e.target);
          await postJSON(`/api/v1/nodes/${selectedNodeId}/time-entries`, { user_id: fd.get('user_id'), hours: parseFloat(fd.get('hours')) || 0 });
          e.target.reset();
          await refreshLists(selectedNodeId);
        });

        // Radio groups helpers and handlers
        function getStatusPalette(val){
          switch(String(val)){
            case 'planned': return { solid: '#38bdf8', soft: '#f0f9ff', border: '#0ea5e9' }; // sky-400 / sky-50 / sky-500
            case 'in-progress': return { solid: '#f59e0b', soft: '#fffbeb', border: '#d97706' }; // amber-500 / amber-50 / amber-600
            case 'discuss': return { solid: '#8b5cf6', soft: '#f5f3ff', border: '#7c3aed' }; // violet-500 / violet-50 / violet-600
            case 'done': return { solid: '#22c55e', soft: '#ecfdf5', border: '#16a34a' }; // emerald-500 / emerald-50 / emerald-600
            case 'blocked': return { solid: '#ef4444', soft: '#fef2f2', border: '#dc2626' }; // red-500 / red-50 / red-600
            default: return { solid: '#64748b', soft: '#e2e8f0', border: '#475569' }; // slate-500 / slate-200 / slate-600
          }
        }
        function getPriorityPalette(val){
          switch(String(val)){
            case 'low': return { solid: '#94a3b8', soft: '#e2e8f0', border: '#64748b' }; // slate-400 / slate-200 / slate-500
            case 'normal': return { solid: '#64748b', soft: '#e2e8f0', border: '#475569' }; // slate-500 / slate-200 / slate-600
            case 'high': return { solid: '#f59e0b', soft: '#fffbeb', border: '#d97706' }; // amber-500 / amber-50 / amber-600
            case 'critical': return { solid: '#ef4444', soft: '#fef2f2', border: '#dc2626' }; // red-500 / red-50 / red-600
            default: return { solid: '#64748b', soft: '#e2e8f0', border: '#475569' };
          }
        }
        function getPaletteFor(groupEl, val){
          const id = (groupEl && groupEl.id) || '';
          if (id === 'statusRadios') return getStatusPalette(val);
          if (id === 'priorityRadios') return getPriorityPalette(val);
          return { solid: '#64748b', soft: '#e2e8f0' };
        }
        function setRadioGroupValue(groupEl, value){
          if (!groupEl) return;
          const buttons = Array.from(groupEl.querySelectorAll('button[data-value]'));
          buttons.forEach(btn => {
            const btnVal = String(btn.dataset.value || '');
            const isActive = btnVal === String(value);
            const pal = getPaletteFor(groupEl, btnVal);
            btn.setAttribute('aria-checked', isActive ? 'true' : 'false');
            btn.className = 'px-2 py-1 text-xs rounded w-full transition-colors';
            btn.style.backgroundColor = isActive ? pal.solid : pal.soft;
            btn.style.color = isActive ? '#ffffff' : pal.solid;
            btn.style.borderStyle = 'solid';
            btn.style.borderWidth = isActive ? '2px' : '0';
            btn.style.borderColor = isActive ? pal.border : 'transparent';
          });
        }
        (function wireStatusRadios(){
          const grp = document.getElementById('statusRadios');
          if (!grp) return;
          grp.addEventListener('click', async (e) => {
            const btn = e.target && e.target.closest ? e.target.closest('button[data-value]') : null;
            if (!btn) return;
            if (!selectedNodeId) return;
            const value = String(btn.dataset.value || '');
            if (!value) return;
            if (btn.getAttribute('aria-checked') === 'true') { setRadioGroupValue(grp, value); return; }
            const resp = await patchJSON(`/api/v1/nodes/${selectedNodeId}`, { status: value });
            const n = cy.getElementById(selectedNodeId);
            if (n && n.nonempty()) n.data('status', resp.data.status || value);
            setRadioGroupValue(grp, resp.data.status || value);
            refreshEdgeTargetFlags(selectedNodeId);
            recomputePriorityPaths();
            try { await refreshLists(selectedNodeId); } catch {}
          });
          grp.addEventListener('keydown', (e) => {
            const k = (e.key || '').toLowerCase();
            if (k === 'enter' || k === ' ') { const f = document.activeElement && document.activeElement.closest && document.activeElement.closest('button[data-value]'); if (f) { e.preventDefault(); f.click(); } }
          });
        })();
        (function wirePriorityRadios(){
          const grp = document.getElementById('priorityRadios');
          if (!grp) return;
          grp.addEventListener('click', async (e) => {
            const btn = e.target && e.target.closest ? e.target.closest('button[data-value]') : null;
            if (!btn) return;
            if (!selectedNodeId) return;
            const value = String(btn.dataset.value || '');
            if (!value) return;
            if (btn.getAttribute('aria-checked') === 'true') { setRadioGroupValue(grp, value); return; }
            const resp = await patchJSON(`/api/v1/nodes/${selectedNodeId}`, { priority: value });
            const n = cy.getElementById(selectedNodeId);
            if (n && n.nonempty()) n.data('priority', resp.data.priority || value);
            setRadioGroupValue(grp, resp.data.priority || value);
            refreshEdgeTargetFlags(selectedNodeId);
            recomputePriorityPaths();
          });
          grp.addEventListener('keydown', (e) => {
            const k = (e.key || '').toLowerCase();
            if (k === 'enter' || k === ' ') { const f = document.activeElement && document.activeElement.closest && document.activeElement.closest('button[data-value]'); if (f) { e.preventDefault(); f.click(); } }
          });
        })();

        // Hide from board checkbox wiring
        (function wireHideToggle(){
          const chk = document.getElementById('hideFromBoard');
          if (!chk) return;
          chk.addEventListener('change', async () => {
            if (!selectedNodeId) { chk.checked = !chk.checked; return; }
            const desired = !!chk.checked;
            chk.disabled = true;
            try {
              const resp = await patchJSON(`/api/v1/nodes/${selectedNodeId}`, { is_hidden: desired });
              const n = cy.getElementById(String(selectedNodeId));
              if (desired) {
                // remove node from cy and clear selection
                if (n && n.nonempty()) n.remove();
                selectedNodeId = null;
                selEl.textContent = '—';
                const delBtn = document.getElementById('btnDeleteNodePanel');
                if (delBtn) delBtn.classList.add('hidden');
              } else {
                // In normal mode we wouldn't see hidden nodes; if recovery mode appears later, update style here
                if (n && n.nonempty()) n.data('is_hidden', !!(resp && resp.data && resp.data.is_hidden));
              }
            } catch (e) {
              // revert on error
              chk.checked = !chk.checked;
              alert((e && e.message) || 'Failed to update hidden flag');
            } finally {
              chk.disabled = false;
            }
          });
        })();

        document.getElementById('costForm').addEventListener('submit', async (e) => {
          e.preventDefault();
          if (!selectedNodeId) return;
          const fd = new FormData(e.target);
          await postJSON(`/api/v1/nodes/${selectedNodeId}/cost-entries`, { amount: parseFloat(fd.get('amount')) || 0, currency: 'USD', incurred_at: new Date().toISOString() });
          e.target.reset();
          await refreshLists(selectedNodeId);
        });

        document.getElementById('btnAddNode').addEventListener('click', async () => {
          const title = prompt('Node title');
          if (!title) return;
          const resp = await postJSON(`/api/v1/projects/${projectId}/nodes`, { title });
          addNodeToCy(resp.data);
        });

        // Removed old Edit Node toolbar flow (replaced by inline editor)

        // Inline edit selected node title (Task Panel)
        const titleInlineEl = document.getElementById('selNodeTitle');
        function commitInlineTitle(){
          if (!selectedNodeId) return;
          const newTitle = (titleInlineEl.textContent || '').trim();
          if (!newTitle) { return; }
          patchJSON(`/api/v1/nodes/${selectedNodeId}`, { title: newTitle })
            .then(resp => {
              const n = cy.getElementById(selectedNodeId);
              if (n) n.data('label', resp.data.title);
            })
            .catch(()=>{});
        }
        titleInlineEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') { e.preventDefault(); commitInlineTitle(); titleInlineEl.blur(); }
        });
        titleInlineEl.addEventListener('blur', () => commitInlineTitle());

        // Link URL field: save on blur/Enter, toggle hint visibility
        (function wireLinkUrl(){
          const input = document.getElementById('selNodeLinkUrl');
          const hint = document.getElementById('linkHint');
          const chk = document.getElementById('openInNewTab');
          if (!input) return;
          // initialize checkbox from storage
          if (chk){
            const saved = localStorage.getItem('openLinkInNewTab');
            chk.checked = (saved === null || saved === '1');
            chk.addEventListener('change', async () => {
              localStorage.setItem('openLinkInNewTab', chk.checked ? '1' : '0');
              if (selectedNodeId) {
                try {
                  const resp = await patchJSON(`/api/v1/nodes/${selectedNodeId}`, { link_open_in_new_tab: !!chk.checked });
                  const n = cy.getElementById(String(selectedNodeId));
                  if (n && n.nonempty()) n.data('link_open_in_new_tab', !!(resp && resp.data && resp.data.link_open_in_new_tab));
                } catch {}
              }
            });
          }
          async function commit(){
            if (!selectedNodeId) return;
            const raw = (input.value || '').trim();
            const payload = { link_url: raw || null };
            try {
              const resp = await patchJSON(`/api/v1/nodes/${selectedNodeId}`, payload);
              const url = resp && resp.data ? (resp.data.link_url || '') : (raw || '');
              // update cy data and hint
              const n = cy.getElementById(String(selectedNodeId));
              if (n && n.nonempty()) n.data('link_url', url || null);
              if (hint) { if (url) hint.classList.remove('hidden'); else hint.classList.add('hidden'); }
            } catch (e) {
              const msg = (e && e.message) ? e.message : 'Invalid link URL';
              alert(msg);
            }
          }
          input.addEventListener('keydown', (e)=>{ if (e.key === 'Enter'){ e.preventDefault(); input.blur(); } });
          input.addEventListener('blur', ()=>commit());
        })();

        document.getElementById('btnDeleteNodePanel').addEventListener('click', async () => {
          if (!selectedNodeId) { alert('Select a node'); return; }
          if (!confirm('Delete node?')) return;
          await del(`/api/v1/nodes/${selectedNodeId}`);
          cy.getElementById(selectedNodeId).remove();
          selectedNodeId = null;
          selEl.textContent = '—';
        });

        // Unified connect mode: via button or hold 'c'. ESC / click background cancels. Prevent dup/invalid.
        (function connectMode(){
          let active = false; let sourceId = null; let timeoutId = null;
          const srcClass = 'connect-source';
          // hint overlay
          const hint = document.createElement('div');
          hint.className = 'pointer-events-none fixed inset-x-0 top-16 text-center z-40';
          hint.style.display = 'none';
          hint.innerHTML = '<span class="inline-block px-3 py-1 bg-black/70 text-white rounded">Connect mode: click source, then target (ESC to cancel, hold C/С for quick connect)</span>';
          document.body.appendChild(hint);
          function setActive(on){
            active = on; if (!on) { sourceId = null; cy.nodes().removeClass(srcClass); if (timeoutId) { clearTimeout(timeoutId); timeoutId=null; } cy.container().style.cursor=''; hint.style.display='none'; }
            else { cy.container().style.cursor='crosshair'; hint.style.display=''; timeoutId = setTimeout(()=>setActive(false), 10000); }
          }
          function cancel(){ setActive(false); }
          function tryCreateEdge(targetId){
            if (!sourceId || sourceId === targetId) return;
            const srcEl = cy.getElementById(sourceId); const tgtEl = cy.getElementById(targetId);
            if (!srcEl.nonempty() || !tgtEl.nonempty()) { cancel(); return; }
            // prevent duplicates
            const dup = cy.edges().some(e => e.data('source')===sourceId && e.data('target')===targetId);
            if (dup) { cancel(); return; }
            postJSON(`/api/v1/projects/${projectId}/edges`, { source_node_id: sourceId, target_node_id: targetId })
              .then(resp => addEdgeToCy(resp.data))
              .finally(() => cancel());
          }
          const pickHandler = (evt) => {
            if (!active) return;
            const id = evt.target.data('id');
            if (!sourceId) { sourceId = id; cy.getElementById(sourceId).addClass(srcClass); }
            else { tryCreateEdge(id); }
          };
          cy.on('tap', 'node', pickHandler);
          cy.on('tap', (evt) => { if (active && evt.target === cy) cancel(); });
          const isConnectKey = (k) => { const v=(k||'').toLowerCase(); return v==='c' || v==='с'; };
          document.addEventListener('keydown', (e)=>{ if (isConnectKey(e.key) && !active){ setActive(true); }});
          document.addEventListener('keyup', (e)=>{ if (isConnectKey(e.key)){ cancel(); }});
          document.getElementById('btnAddEdge').addEventListener('click', ()=>{ setActive(true); });
          document.addEventListener('keydown', (e)=>{ if (e.key==='Escape' && active){ e.preventDefault(); cancel(); }});
        })();

        // Edge delete helper (invoked by keyboard shortcut)
        async function deleteSelectedEdge(){
          if (!selectedEdgeId) { alert('Tap an edge to select it'); return; }
          if (!confirm('Delete edge?')) return;
          await del(`/api/v1/edges/${selectedEdgeId}`);
          cy.getElementById(selectedEdgeId).remove();
          selectedEdgeId = null;
        }

        document.getElementById('btnCriticalPath').addEventListener('click', async () => {
          const res = await fetch(`/api/v1/projects/${projectId}/metrics`).then(r=>r.json());
          const ids = (res.data && res.data.critical_path_hint && res.data.critical_path_hint.node_ids) || [];
          cy.elements().removeClass('cp');
          ids.forEach((id, i) => {
            const el = cy.getElementById(id);
            el.addClass('cp');
          });
        });

        // Multi-select (hold Shift to select multiple)
        let multiSelected = new Set();
        cy.on('tap', 'node', (evt) => {
          if (evt.originalEvent && evt.originalEvent.shiftKey) {
            const id = evt.target.id();
            if (multiSelected.has(id)) multiSelected.delete(id); else multiSelected.add(id);
            evt.target.toggleClass('cp');
          } else {
            multiSelected.clear();
          }
        });

        document.getElementById('btnGroup').addEventListener('click', async () => {
          if (multiSelected.size < 1) { alert('Hold Shift and select nodes to group'); return; }
          const title = prompt('Group title', 'Group') || 'Group';
          const ids = Array.from(multiSelected);
          const res = await postJSON(`/api/v1/projects/${projectId}/groups`, { title, node_ids: ids });
          // reload graph for simplicity
          graph = await fetchGraph();
          cy.elements().remove();
          cy.add(toElements(graph));
          cy.layout({ name: 'preset' }).run();
          cy.fit();
          multiSelected.clear();
        });

        document.getElementById('btnUngroup').addEventListener('click', async () => {
          if (!selectedNodeId) { alert('Select a group node'); return; }
          const nd = cy.getElementById(selectedNodeId);
          if (!nd || !nd.data('is_group')) { alert('Selected node is not a group'); return; }
          await postJSON(`/api/v1/groups/${selectedNodeId}/ungroup`, {});
          graph = await fetchGraph();
          cy.elements().remove();
          cy.add(toElements(graph));
          cy.layout({ name: 'preset' }).run();
          try { applyLOD(); applySearchAndFilter(); } catch {}
        });

        // Collapse / Expand groups (pure UI)
        const collapsedGroups = new Set((JSON.parse(localStorage.getItem('collapsedGroups') || '[]') || []).map(String));
        function persistCollapsed() {
          localStorage.setItem('collapsedGroups', JSON.stringify(Array.from(collapsedGroups)));
        }
        function collapseGroup(groupId) {
          const gid = String(groupId);
          const children = cy.nodes().filter(n => String(n.data('parent')) === gid);
          children.forEach(ch => { ch.data('origParent', gid); ch.move({ parent: null }); ch.style('display', 'none'); });
          const grp = cy.getElementById(groupId);
          if (grp) grp.addClass('collapsed');
        }
        function expandGroup(groupId) {
          const gid = String(groupId);
          const children = cy.nodes().filter(n => String(n.data('origParent')) === gid);
          children.forEach(ch => { ch.move({ parent: gid }); ch.removeData('origParent'); ch.style('display', 'element'); });
          const grp = cy.getElementById(groupId);
          if (grp) grp.removeClass('collapsed');
        }
        // Apply persisted states after initial render
        // 1) Collapse ALL groups by default
        cy.nodes('[?is_group]').forEach(g => collapseGroup(g.id()));
        // 2) Expand those that are not in persisted collapsed set
        cy.nodes('[?is_group]').forEach(g => {
          if (!collapsedGroups.has(String(g.id()))) {
            expandGroup(g.id());
          }
        });

        // 3) Re-apply saved positions for groups to override any layout shifts
        function reapplySavedGroupPositions() {
          cy.nodes('[?is_group]').forEach(g => {
            const x = g.data('savedX');
            const y = g.data('savedY');
            if (typeof x === 'number' && typeof y === 'number') {
              g.position({ x, y });
            }
          });
        }
        reapplySavedGroupPositions();

        document.getElementById('btnCollapse').addEventListener('click', () => {
          if (!selectedNodeId) { alert('Select a group node'); return; }
          const nd = cy.getElementById(selectedNodeId);
          if (!nd || !nd.data('is_group')) { alert('Selected node is not a group'); return; }
          collapseGroup(selectedNodeId);
          collapsedGroups.add(selectedNodeId);
          persistCollapsed();
        });

        document.getElementById('btnExpand').addEventListener('click', () => {
          if (!selectedNodeId) { alert('Select a group node'); return; }
          const nd = cy.getElementById(selectedNodeId);
          if (!nd || !nd.data('is_group')) { alert('Selected node is not a group'); return; }
          expandGroup(selectedNodeId);
          collapsedGroups.delete(selectedNodeId);
          persistCollapsed();
        });

        // Double-click (fast two taps) on group to toggle collapse/expand
        let lastTapAt = 0;
        let lastTapId = null;
        cy.on('tap', 'node', (evt) => {
          // ignore when using Shift multi-select
          if (evt.originalEvent && evt.originalEvent.shiftKey) return;
          const id = evt.target.id();
          const now = Date.now();
          if (evt.target.data('is_group') && lastTapId === id && (now - lastTapAt) < 300) {
            const isCollapsed = collapsedGroups.has(id);
            if (isCollapsed) { expandGroup(id); collapsedGroups.delete(id); }
            else { collapseGroup(id); collapsedGroups.add(id); }
            persistCollapsed();
            lastTapAt = 0; lastTapId = null;
          } else {
            lastTapAt = now; lastTapId = id;
          }
        });

        // LOD: zoom-aware visibility using lod_score with strong safeguards
        function applyLOD() {
          const z = cy.zoom();
          const allNodes = cy.nodes();
          const baseNodes = allNodes.filter(n => !Boolean(n.data('origParent')));
          const total = baseNodes.length;

          // Reset opacities for base nodes before applying rules
          allNodes.forEach(n => { if (!n.data('origParent')) { n.style('opacity', 1); } });

          // Respect user preference: when disabled, always show everything
          if (!getLodEnabled()) {
            baseNodes.forEach(n => { n.style('display', 'element'); n.style('opacity', 1); });
            return;
          }

          // Disable LOD for small graphs or near/full zoom
          if (total <= 150 || z >= 0.8) {
            baseNodes.forEach(n => { n.style('display', 'element'); n.style('opacity', 1); });
            return;
          }

          const selectedId = selectedNodeId ? String(selectedNodeId) : null;
          const minVisible = Math.min(80, Math.ceil(total * 0.2));
          const targetRatio = (z < 0.4) ? 0.25 : 0.6; // low vs mid zoom targets
          let desiredVisible = Math.max(minVisible, Math.ceil(total * targetRatio));

          // Rank nodes by lod_score (desc)
          const ranked = baseNodes.map(n => ({ id: n.id(), node: n, score: Number(n.data('lod_score') || 0) }))
                                  .sort((a, b) => b.score - a.score);

          // Choose visible set
          const visibleSet = new Set();
          for (let i = 0; i < ranked.length && visibleSet.size < desiredVisible; i++) {
            visibleSet.add(ranked[i].id);
          }
          if (selectedId) visibleSet.add(selectedId);

          // Medium zoom: keep all displayed, fade out lower-importance nodes
          if (z >= 0.4 && z < 0.8) {
            baseNodes.forEach(n => {
              const isVisible = visibleSet.has(n.id());
              n.style('display', 'element');
              n.style('opacity', isVisible ? 1 : 0.25);
            });
            return;
          }

          // Low zoom: hide least important nodes
          baseNodes.forEach(n => {
            const isVisible = visibleSet.has(n.id());
            n.style('opacity', 1);
            n.style('display', isVisible ? 'element' : 'none');
          });

          // Safety: ensure at least minVisible are shown (avoid single-selected trap)
          const currentlyVisible = baseNodes.filter(n => n.style('display') !== 'none').length;
          if (currentlyVisible < minVisible) {
            const toShow = new Set();
            for (let i = 0; i < Math.min(minVisible, ranked.length); i++) {
              toShow.add(ranked[i].id);
            }
            baseNodes.forEach(n => { if (toShow.has(n.id())) n.style('display', 'element'); });
          }
        }
        cy.on('zoom', applyLOD);
        applyLOD();
        try { checkAndAutoOpenLinkOnOversized(); } catch {}

        // Pick a focus node when none is selected: prioritize node under viewport center with a link
        function findFocusedNodeForZoom(){
          try {
            const all = cy.nodes();
            if (!all || all.length === 0) return null;
            const vpW = cy.width();
            const vpH = cy.height();
            const cx = vpW / 2;
            const cyy = vpH / 2;
            let best = null;
            let bestRank = null; // tuple: [insideCenter (1|0), sizeScore, -distance]
            all.forEach(n => {
              try {
                if (!n || !n.nonempty()) return;
                if (n.style('display') === 'none') return;
                const url = String(n.data('link_url') || '').trim();
                if (!url) return; // focus only on nodes that can open
                const box = n.renderedBoundingBox();
                const inside = (box.x1 <= cx && cx <= box.x2 && box.y1 <= cyy && cyy <= box.y2) ? 1 : 0;
                const sizeScore = ((box.w / vpW) + (box.h / vpH)) / 2; // 0..~
                const nx = (box.x1 + box.x2) / 2; const ny = (box.y1 + box.y2) / 2;
                const dx = nx - cx; const dy = ny - cyy;
                const diag = Math.sqrt(vpW*vpW + vpH*vpH) || 1;
                const distNorm = Math.sqrt(dx*dx + dy*dy) / diag; // 0..~1
                const rank = [inside, sizeScore, -distNorm];
                if (!bestRank || rank[0] > bestRank[0] || (rank[0] === bestRank[0] && (rank[1] > bestRank[1] || (rank[1] === bestRank[1] && rank[2] > bestRank[2])))){
                  best = n; bestRank = rank;
                }
              } catch {}
            });
            return best ? String(best.id()) : null;
          } catch { return null; }
        }

        function prewarmForUrl(rawUrl){
          try {
            const url = String(rawUrl || '').trim();
            if (!url) return;
            if (prefetchedUrls.has(url)) return;
            prefetchedUrls.add(url);
            // DNS Prefetch & Preconnect for origin
            try {
              const u = new URL(url, window.location.href);
              const origin = u.origin;
              if (!prefetchedOrigins.has(origin)){
                prefetchedOrigins.add(origin);
                const l1 = document.createElement('link'); l1.rel = 'dns-prefetch'; l1.href = origin; document.head.appendChild(l1);
                const l2 = document.createElement('link'); l2.rel = 'preconnect'; l2.href = origin; l2.crossOrigin = 'anonymous'; document.head.appendChild(l2);
              }
            } catch {}
            // Soft prefetch (low priority)
            try {
              const l3 = document.createElement('link'); l3.rel = 'prefetch'; l3.href = url; l3.as = 'document'; l3.crossOrigin = 'anonymous'; document.head.appendChild(l3);
            } catch {}
            // Also enqueue Speculation Rules prefetch (works even if unsupported; browser will ignore)
            try {
              const u = new URL(url, window.location.href);
              const href = u.href;
              if (!specPrefetchUrls.has(href)){
                specPrefetchUrls.add(href);
                updateSpeculationRulesScript();
              }
            } catch {}
          } catch {}
        }

        function updateSpeculationRulesScript(){
          try {
            const prefetch = Array.from(specPrefetchUrls);
            const prerender = Array.from(specPrerenderUrls);
            const obj = {};
            if (prefetch.length) obj.prefetch = [{ source: 'list', urls: prefetch }];
            if (prerender.length) obj.prerender = [{ source: 'list', urls: prerender }];
            let el = document.getElementById('speculationRulesDynamic');
            if (!el){
              el = document.createElement('script');
              el.type = 'speculationrules';
              el.id = 'speculationRulesDynamic';
              document.head.appendChild(el);
            }
            el.textContent = JSON.stringify(obj);
          } catch {}
        }

        function tryQueuePrerender(rawUrl){
          try {
            const url = String(rawUrl || '').trim();
            if (!url) return;
            const u = new URL(url, window.location.href);
            if (u.origin !== window.location.origin) return; // prerender: restrict to same-origin for safety/compatibility
            const href = u.href;
            if (specPrerenderUrls.has(href)) return;
            specPrerenderUrls.add(href);
            updateSpeculationRulesScript();
          } catch {}
        }

        // Auto-open link when selected (or focused) node becomes large relative to viewport
        function checkAndAutoOpenLinkOnOversized(){
          try {
            let idToCheck = selectedNodeId;
            if (!idToCheck) { idToCheck = findFocusedNodeForZoom(); }
            if (!idToCheck) return;
            const n = cy.getElementById(String(idToCheck));
            if (!n || !n.nonempty()) return;
            const url = String(n.data('link_url') || '').trim();
            if (!url) return;
            const box = n.renderedBoundingBox();
            const vpW = cy.width();
            const vpH = cy.height();
            // Primary strict threshold and secondary relaxed threshold
            const RATIO_TH_PRIMARY = 0.98; // ~full-screen
            const RATIO_TH_SECONDARY = 0.6; // large portion of the screen
            const MAX_ZOOM_OPEN_LEVEL = 47.5; // near-custom max 50
            const primaryOversized = (box.w >= vpW * RATIO_TH_PRIMARY) || (box.h >= vpH * RATIO_TH_PRIMARY);
            const secondaryOversized = (box.w >= vpW * RATIO_TH_SECONDARY) || (box.h >= vpH * RATIO_TH_SECONDARY);
            const nearMaxZoom = (cy.zoom() >= MAX_ZOOM_OPEN_LEVEL);
            const shouldOpen = primaryOversized || (nearMaxZoom && secondaryOversized);
            // Prewarm a bit earlier than open trigger
            try {
              const PREWARM_RATIO = 0.4; // gentle
              const PRERENDER_RATIO = 0.8; // aggressive: when very likely to navigate soon
              const nearOpen = (box.w >= vpW * PREWARM_RATIO) || (box.h >= vpH * PREWARM_RATIO) || nearMaxZoom;
              if (nearOpen) prewarmForUrl(url);
              const veryLikely = primaryOversized || (box.w >= vpW * PRERENDER_RATIO) || (box.h >= vpH * PRERENDER_RATIO) || nearMaxZoom;
              if (veryLikely) tryQueuePrerender(url);
            } catch {}
            // Debug logs (enable with localStorage.setItem('oversizeDebug','1'))
            try {
              if (localStorage.getItem('oversizeDebug') === '1'){
                const now = Date.now();
                if (now - lastOversizeDebugAt > 120) {
                  lastOversizeDebugAt = now;
                  console.log('[OversizeDebug]', {
                    selectedNodeId,
                    focusNodeId: idToCheck,
                    zoom: cy.zoom(),
                    box, vpW, vpH,
                    primaryOversized, secondaryOversized, nearMaxZoom, shouldOpen,
                    fired: oversizedOpenFiredForNodeIds.has(String(idToCheck))
                  });
                }
              }
            } catch {}
            if (!shouldOpen) return;
            const id = String(idToCheck);
            if (oversizedOpenFiredForNodeIds.has(id)) return;
            oversizedOpenFiredForNodeIds.add(id);
            // Force open in current tab regardless of per-node preference
            location.assign(url);
          } catch {}
        }
        cy.on('zoom', checkAndAutoOpenLinkOnOversized);

        // Reset helpers
        // Ensure auto-open can trigger again after browser back/forward (BFCache restore)
        try {
          window.addEventListener('pageshow', () => {
            try {
              oversizedOpenFiredForNodeIds.clear();
              lastOversizeDebugAt = 0;
              // Optional: clear speculative caches to refresh preconnect/prefetch state
              try { prefetchedOrigins.clear(); prefetchedUrls.clear(); specPrefetchUrls.clear(); specPrerenderUrls.clear(); updateSpeculationRulesScript(); } catch {}
            } catch {}
          });
        } catch {}
        function visibleCount(){
          let shown = 0; cy.nodes().forEach(n=>{ if (n.style('display') !== 'none' && !n.data('origParent')) shown++; }); return shown;
        }
        function resetCollapsed(){
          collapsedGroups.clear(); persistCollapsed();
          cy.nodes('[?is_group]').forEach(g=>{ expandGroup(g.id()); });
        }
        function resetFilters(){
          const s=document.getElementById('statusFilter'); if (s) s.value='';
          const q=document.getElementById('searchBox'); if (q) q.value='';
          applySearchAndFilter();
        }
        function showAllAndFit(){
          resetCollapsed(); resetFilters();
          cy.nodes().forEach(n=>{ if (!n.data('origParent')) n.style('display','element'); });
          cy.zoom(1); cy.fit();
          console.log('[AutoFix] showAllAndFit applied. nodes:', cy.nodes().length, 'visible:', visibleCount());
        }
        document.getElementById('btnResetView').addEventListener('click', showAllAndFit);

        // Auto self-heal: if after initial render ничего не видно — сбросить вид
        setTimeout(() => {
          try {
            const vis = visibleCount();
            if (cy.nodes().length > 0 && vis === 0) { showAllAndFit(); }
          } catch {}
        }, 300);

        // Search/filter
        function applySearchAndFilter() {
          const q = (document.getElementById('searchBox').value || '').toLowerCase();
          const f = (document.getElementById('statusFilter').value || '').toLowerCase();
          cy.nodes().forEach(n => {
            const matchesText = !q || (String(n.data('label') || '').toLowerCase().includes(q));
            // Internal status uses 'planned' for what UI calls 'Todo'
            const statusValue = String(n.data('status') || '').toLowerCase();
            const filterValue = f === 'planned' ? 'planned' : f;
            const matchesStatus = !f || (statusValue === filterValue);
            n.style('opacity', (matchesText && matchesStatus) ? 1 : 0.15);
          });
        }
        document.getElementById('searchBox').addEventListener('input', applySearchAndFilter);
        document.getElementById('statusFilter').addEventListener('change', applySearchAndFilter);

        // Fit
        document.getElementById('btnFit').addEventListener('click', () => cy.fit());

        // LOD toggle wiring
        (function initLodToggle(){
          const lodChk = document.getElementById('lodToggle');
          if (lodChk) {
            lodChk.checked = getLodEnabled();
            lodChk.addEventListener('change', () => {
              setLodEnabled(!!lodChk.checked);
              try { applyLOD(); } catch {}
            });
          }
        })();

        // Language toggle
        const langSel = null; // toolbar lang removed; use Settings control
        async function ensureTranslations(lang){
          if (!lang) return;
          try { await fetch(`/api/v1/projects/${projectId}/translate`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ lang, include_nodes: true, stale: false }) }); } catch {}
        }
        async function handleLanguageChange(lang){
          const val = lang || '';
          localStorage.setItem('displayLang', val);
          if (val) { try { await ensureTranslations(val); } catch {} }
          graph = await fetchGraph(val);
          cy.elements().remove();
          cy.add(toElements(graph));
          cy.layout({ name: 'preset' }).run();
          cy.fit();
          // Recompute edge path colors based on current graph
          try { recomputePriorityPaths(); } catch {}
          // Re-apply LOD and filters after reload
          try { applyLOD(); applySearchAndFilter(); } catch {}
        }

        try { document.getElementById('btnTrStats').addEventListener('click', async ()=>{
          const lang = getCurrentLang() || 'en';
          try {
            const s = await fetch(`/api/v1/projects/${projectId}/translation/stats?lang=${encodeURIComponent(lang)}`).then(r=>r.json());
            const d = s.data || {};
            alert(`Translation stats (${lang}):\nMissing nodes: ${d.missing_nodes}\nStale nodes: ${d.stale_nodes}\nMissing comments: ${d.missing_comments}\nStale comments: ${d.stale_comments}`);
          } catch { alert('Failed to fetch stats'); }
        }); } catch {}

        try { document.getElementById('btnTrRun').addEventListener('click', async ()=>{
          const lang = getCurrentLang() || 'en';
          const btn = document.getElementById('btnTrRun');
          const oldText = btn.textContent;
          let preflightTotalAll = 0;
          // Ask user for mode: OK => force overwrite all; Cancel => only missing/stale
          const forceMode = window.confirm('Force mode?\nOK = overwrite ALL existing translations (force=true)\nCancel = only missing/stale (force=false)');
          try {
            btn.disabled = true; btn.textContent = 'Translating…';
            // Preflight: if nothing to translate, stop early and re-enable
            try {
              const s = await fetch(`/api/v1/projects/${projectId}/translation/stats?lang=${encodeURIComponent(lang)}`).then(r=>r.json());
              const d = s?.data || {};
              const totalAll = (d.total_nodes||0) + (d.total_comments||0);
              preflightTotalAll = totalAll;
              btn.textContent = `Translating… 0/${totalAll}`;
              const totalLeft = (d.missing_nodes||0)+(d.stale_nodes||0)+(d.missing_comments||0)+(d.stale_comments||0);
              if (!totalLeft) {
                btn.disabled = false; btn.textContent = oldText;
                alert('Nothing to translate');
                return;
              }
            } catch {}
            // Sync translate (temporary fallback while async queue is under maintenance)
            const syncResp = await fetch(`/api/v1/projects/${projectId}/translate`, {
              method: 'POST', headers: {'Content-Type': 'application/json'},
              body: JSON.stringify({ lang, include_nodes: true, include_comments: true, stale: true, provider: 'gemini', force: !!forceMode })
            });
            if (!syncResp.ok) {
              let detail = '';
              try {
                const t = await syncResp.text();
                detail = (t || '').slice(0, 2000);
              } catch {}
              // Show copyable error panel
              (async function(){
                let panel = document.getElementById('copyableErrorPanel');
                if (!panel){
                  panel = document.createElement('div');
                  panel.id = 'copyableErrorPanel';
                  panel.style.position = 'fixed';
                  panel.style.left = '50%';
                  panel.style.top = '50%';
                  panel.style.transform = 'translate(-50%, -50%)';
                  panel.style.zIndex = '9999';
                  panel.style.width = '520px';
                  panel.style.maxWidth = '92vw';
                  panel.style.background = '#111827';
                  panel.style.color = '#e5e7eb';
                  panel.style.border = '1px solid #374151';
                  panel.style.borderRadius = '8px';
                  panel.style.boxShadow = '0 10px 20px rgba(0,0,0,0.3)';
                  panel.style.padding = '12px';
                  panel.style.maxHeight = '80vh';
                  panel.style.overflow = 'auto';

                  const title = document.createElement('div');
                  title.textContent = 'Error details';
                  title.style.fontWeight = '600';
                  title.style.marginBottom = '8px';
                  panel.appendChild(title);

                  const ta = document.createElement('textarea');
                  ta.id = 'copyableErrorText';
                  ta.readOnly = true;
                  ta.style.width = '100%';
                  ta.style.height = '160px';
                  ta.style.background = '#0b1220';
                  ta.style.color = '#e5e7eb';
                  ta.style.border = '1px solid #374151';
                  ta.style.borderRadius = '6px';
                  ta.style.padding = '8px';
                  ta.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
                  panel.appendChild(ta);

                  const row = document.createElement('div');
                  row.style.display = 'flex';
                  row.style.gap = '8px';
                  row.style.marginTop = '8px';

                  const btnCopy = document.createElement('button');
                  btnCopy.textContent = 'Copy';
                  btnCopy.className = 'px-3 py-1 bg-slate-200 text-slate-800 rounded';
                  btnCopy.addEventListener('click', ()=>{ ta.select(); try { document.execCommand('copy'); } catch {} });
                  row.appendChild(btnCopy);

                  const btnClose = document.createElement('button');
                  btnClose.textContent = 'Close';
                  btnClose.className = 'px-3 py-1 bg-slate-200 text-slate-800 rounded';
                  btnClose.addEventListener('click', ()=>{ panel.style.display = 'none'; });
                  row.appendChild(btnClose);

                  panel.appendChild(row);
                  document.body.appendChild(panel);
                }
                // fetch pid
                let pid = '';
                try { const h = await fetch('/api/v1/health').then(r=>r.json()); pid = (h && h.data && h.data.pid) ? String(h.data.pid) : ''; } catch {}
                const taEl = document.getElementById('copyableErrorText');
                if (taEl){ taEl.value = `sync failed (${syncResp.status}) pid=${pid}\n${detail}`; taEl.select(); }
                panel.style.display = '';
              })();
              btn.disabled = false; btn.textContent = oldText;
              return;
            }
            const sync = await syncResp.json();
            const translated = (sync && sync.data && sync.data.translated) || 0;
            btn.disabled = false; btn.textContent = oldText;
            alert(`Done. Translated: ${translated}`);
            const currentLang = (document.getElementById('langSelect')?.value || '');
            graph = await fetchGraph(currentLang);
            cy.elements().remove();
            cy.add(toElements(graph));
            cy.layout({ name: 'preset' }).run();
            cy.fit();
          } catch (e) {
            btn.disabled = false; btn.textContent = oldText;
            const msg = (e && e.message) ? e.message : 'Translation failed';
            (async function(){
              let panel = document.getElementById('copyableErrorPanel');
              if (!panel){
                panel = document.createElement('div');
                panel.id = 'copyableErrorPanel';
                panel.style.position = 'fixed';
                panel.style.left = '50%';
                panel.style.top = '50%';
                panel.style.transform = 'translate(-50%, -50%)';
                panel.style.zIndex = '9999';
                panel.style.width = '520px';
                panel.style.maxWidth = '92vw';
                panel.style.background = '#111827';
                panel.style.color = '#e5e7eb';
                panel.style.border = '1px solid #374151';
                panel.style.borderRadius = '8px';
                panel.style.boxShadow = '0 10px 20px rgba(0,0,0,0.3)';
                panel.style.padding = '12px';
                panel.style.maxHeight = '80vh';
                panel.style.overflow = 'auto';
                const title = document.createElement('div');
                title.textContent = 'Error details';
                title.style.fontWeight = '600';
                title.style.marginBottom = '8px';
                panel.appendChild(title);
                const ta = document.createElement('textarea');
                ta.id = 'copyableErrorText';
                ta.readOnly = true;
                ta.style.width = '100%';
                ta.style.height = '160px';
                ta.style.background = '#0b1220';
                ta.style.color = '#e5e7eb';
                ta.style.border = '1px solid #374151';
                ta.style.borderRadius = '6px';
                ta.style.padding = '8px';
                ta.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
                panel.appendChild(ta);
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.gap = '8px';
                row.style.marginTop = '8px';
                const btnCopy = document.createElement('button');
                btnCopy.textContent = 'Copy';
                btnCopy.className = 'px-3 py-1 bg-slate-200 text-slate-800 rounded';
                btnCopy.addEventListener('click', ()=>{ ta.select(); try { document.execCommand('copy'); } catch {} });
                row.appendChild(btnCopy);
                const btnClose = document.createElement('button');
                btnClose.textContent = 'Close';
                btnClose.className = 'px-3 py-1 bg-slate-200 text-slate-800 rounded';
                btnClose.addEventListener('click', ()=>{ panel.style.display = 'none'; });
                row.appendChild(btnClose);
                panel.appendChild(row);
                document.body.appendChild(panel);
              }
              let pid = '';
              try { const h = await fetch('/api/v1/health').then(r=>r.json()); pid = (h && h.data && h.data.pid) ? String(h.data.pid) : ''; } catch {}
              const taEl = document.getElementById('copyableErrorText');
              if (taEl){ taEl.value = (pid ? `pid=${pid}\n` : '') + String(msg||''); taEl.select(); }
              panel.style.display = '';
            })();
          } finally {
            // Safety unlock after 15s in any case
            setTimeout(()=>{ if(btn.disabled){ btn.disabled=false; btn.textContent=oldText; } }, 15000);
          }
        }); } catch {}

        document.getElementById('btnRefreshTranslation').addEventListener('click', async ()=>{
          if (!selectedNodeId) { alert('Select a node'); return; }
          const lang = getCurrentLang() || 'en';
          try {
            const res = await fetch(`/api/v1/nodes/${selectedNodeId}/translate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ lang, provider: 'mymemory' }) }).then(r=>r.json());
            const out = document.getElementById('selNodeTitleTranslated');
            if (out) out.value = (res && res.data && res.data.text) || '';
            // also refresh label for this node in graph if language currently selected
            const currentLang = getCurrentLang() || '';
            if (currentLang) {
              const n = cy.getElementById(String(selectedNodeId));
              if (n && n.nonempty()) n.data('label', out.value || n.data('label'));
            }
          } catch { alert('Failed to refresh translation'); }
        });

        // Zoom controls with smooth animation
        function smoothZoom(factor){
          const target = cy.zoom() * factor;
          const bounded = Math.max(0.05, Math.min(50, target));
          cy.animate({ zoom: bounded }, { duration: 200, easing: 'ease-in-out' });
        }
        document.getElementById('zoomIn').addEventListener('click', () => smoothZoom(1.2));
        document.getElementById('zoomOut').addEventListener('click', () => smoothZoom(1/1.2));
        // smoother wheel zoom (RAF-based, responsive, anchored to cursor)
        cy.userZoomingEnabled(false);
        const cyContainer = cy.container();
        let targetZoom = cy.zoom();
        let anchor = { x: 0, y: 0 };
        let zooming = false;
        function stepZoom(){
          if (!zooming) return;
          const current = cy.zoom();
          const next = current + (targetZoom - current) * 0.25; // responsiveness factor
          cy.zoom({ level: next, renderedPosition: anchor });
          if (Math.abs(targetZoom - next) < 0.001) { zooming = false; return; }
          requestAnimationFrame(stepZoom);
        }
        cyContainer.addEventListener('wheel', (e) => {
          e.preventDefault();
          const rect = cyContainer.getBoundingClientRect();
          anchor = { x: e.clientX - rect.left, y: e.clientY - rect.top };
          const factor = Math.exp(-e.deltaY * 0.0012); // slightly faster response
          targetZoom = Math.max(0.05, Math.min(50, targetZoom * factor));
          if (!zooming) { zooming = true; requestAnimationFrame(stepZoom); }
        }, { passive: false });

        // Toggle sidebar
        const sidebar = document.getElementById('sidebar');
        const toggleBtn = document.getElementById('btnToggleSidebar');
        function applySidebarVisibility(){
          const hidden = localStorage.getItem('sidebarHidden') === '1';
          if (hidden) {
            sidebar.style.display = 'none';
          } else {
            sidebar.style.display = '';
          }
          setTimeout(() => { try { cy.resize(); applyLOD(); applySearchAndFilter(); } catch {} }, 0);
        }
        toggleBtn.addEventListener('click', () => {
          const hidden = localStorage.getItem('sidebarHidden') === '1';
          localStorage.setItem('sidebarHidden', hidden ? '0' : '1');
          applySidebarVisibility();
        });
        applySidebarVisibility();

        // Sidebar resizer
        (function setupResizer(){
          const resizer = document.getElementById('resizer');
          const sidebar = document.getElementById('sidebar');
          const MIN_SIDEBAR = 260;
          const MIN_LEFT = 0; // allow full-width sidebar
          function getContainer(){ return resizer && resizer.parentElement ? resizer.parentElement : (sidebar && sidebar.parentElement ? sidebar.parentElement : document.body); }
          function computeMaxSidebar(){
            const container = getContainer();
            const containerWidth = container ? container.clientWidth : window.innerWidth;
            const resizerWidth = resizer ? (resizer.offsetWidth || 0) : 0;
            const maxSidebar = containerWidth - resizerWidth - MIN_LEFT;
            return Math.max(MIN_SIDEBAR, maxSidebar);
          }
          function applyWidthClamped(px){
            const clamped = Math.max(MIN_SIDEBAR, Math.min(computeMaxSidebar(), px));
            sidebar.style.width = clamped + 'px';
            return clamped;
          }
          function loadWidth(){
            const w = parseInt(localStorage.getItem('sidebarWidth') || '384', 10);
            applyWidthClamped(w);
          }
          loadWidth();
          let dragging = false;
          let startX = 0;
          let startW = 384;
          resizer.addEventListener('mousedown', (e) => {
            dragging = true; startX = e.clientX; startW = sidebar.offsetWidth;
            document.body.classList.add('select-none'); document.body.style.cursor = 'col-resize';
            e.preventDefault();
          });
          window.addEventListener('mouseup', () => {
            if (!dragging) return;
            dragging = false;
            document.body.classList.remove('select-none');
            document.body.style.cursor = '';
            localStorage.setItem('sidebarWidth', parseInt(sidebar.style.width||'384',10));
          });
          window.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            // Dragging left should INCREASE width, right should decrease
            const delta = startX - e.clientX; // left: positive, right: negative
            const proposed = startW + delta;
            applyWidthClamped(proposed);
            cy.resize();
          });
          // Re-clamp on window resize to avoid overflow when viewport shrinks
          window.addEventListener('resize', () => {
            applyWidthClamped(parseInt(sidebar.style.width||'384',10));
            try { cy.resize(); } catch {}
          });
          // Hide resizer if sidebar hidden
          function syncResizer(){ resizer.style.display = (localStorage.getItem('sidebarHidden') === '1') ? 'none' : ''; }
          syncResizer();
          toggleBtn.addEventListener('click', () => { setTimeout(() => { syncResizer(); cy.resize(); }, 0); });
        })();

        // Panel tabs: Task | Actions | Settings
        const tabTask = document.getElementById('tabTask');
        const tabActions = document.getElementById('tabActions');
        const tabSettings = document.getElementById('tabSettings');
        const taskPanel = document.getElementById('taskPanel');
        const actionsPanel = document.getElementById('actionsPanel');
        const settingsPanel = document.getElementById('settingsPanel');
        // ensure declared before any call path
        let settingsLoaded = false;

        // Collapsible sections helper for Settings panel
        function wireCollapsibleSection({ toggleId, bodyId, storageKey, defaultCollapsed }){
          const toggle = document.getElementById(toggleId);
          const body = document.getElementById(bodyId);
          if (!toggle || !body) return;
          // Ensure chevron is on the left side, label next to it, right content grouped
          if (toggle && toggle.dataset.leftChevronWired !== '1'){
            const chevron = toggle.querySelector('[data-chevron]');
            if (chevron){
              // Build left and right groups
              const leftGroup = document.createElement('span');
              leftGroup.className = 'inline-flex items-center gap-2';
              const rightGroup = document.createElement('span');
              rightGroup.className = 'inline-flex items-center gap-2 ml-auto';
              rightGroup.setAttribute('data-right-group','1');
              // Normalize chevron spacing
              chevron.classList.remove('ml-2');
              if (!chevron.classList.contains('mr-2')) chevron.classList.add('mr-2');
              // Identify a primary label element (first non-chevron element)
              const children = Array.from(toggle.children);
              const labelEl = children.find(el => el !== chevron);
              // Rebuild structure: [leftGroup(chevron + label)] [rightGroup(rest)]
              toggle.innerHTML = '';
              if (labelEl){ leftGroup.appendChild(chevron); leftGroup.appendChild(labelEl); }
              else { leftGroup.appendChild(chevron); }
              // Move remaining original children into rightGroup
              children.forEach(el => {
                if (el !== chevron && el !== labelEl) rightGroup.appendChild(el);
              });
              toggle.appendChild(leftGroup);
              toggle.appendChild(rightGroup);
              // Adjust layout to left-justify
              try { toggle.className = (toggle.className || '').replace('justify-between','justify-start'); } catch {}
              toggle.dataset.leftChevronWired = '1';
            }
          }
          const chevron = toggle.querySelector('[data-chevron]');
          function apply(collapsed){
            if (collapsed){
              body.classList.add('hidden');
              toggle.setAttribute('aria-expanded','false');
              if (chevron) chevron.style.transform = 'rotate(-90deg)';
            } else {
              body.classList.remove('hidden');
              toggle.setAttribute('aria-expanded','true');
              if (chevron) chevron.style.transform = 'rotate(0deg)';
            }
          }
          let saved = null;
          try { saved = localStorage.getItem(storageKey); } catch {}
          const def = (defaultCollapsed === true);
          const initialCollapsed = (saved === '1') ? true : (saved === '0') ? false : def;
          apply(initialCollapsed);
          if (toggle.dataset.wired === '1') return;
          toggle.dataset.wired = '1';
          function flip(){
            const isCollapsed = body.classList.contains('hidden');
            apply(!isCollapsed);
            try { localStorage.setItem(storageKey, (!isCollapsed) ? '1' : '0'); } catch {}
          }
          toggle.addEventListener('click', flip);
          toggle.addEventListener('keydown', (e) => {
            const k = (e.key || '').toLowerCase();
            if (k === 'enter' || k === ' '){ e.preventDefault(); flip(); }
          });
        }

        // Task Comments Height Resizer (v2: CSS var + Pointer Events)
        (function(){
          window.setupTaskCommentsResizer = function setupTaskCommentsResizer(){
            const body = document.getElementById('taskCommentsBody');
            const resizerBottom = document.getElementById('taskCommentsResizer');
            const resizerTop = document.getElementById('taskCommentsResizerTop');
            const btnFullscreen = document.getElementById('btnCommentsFullscreen');
            const toggle = document.getElementById('taskCommentsToggle');
            if (!body || !resizerBottom || !resizerTop || !toggle) return;
            if (body.dataset.resizerWired === '1') return;
            body.dataset.resizerWired = '1';

            const STORAGE_KEY = 'sidebar.task.comments.height'; // e.g., '48vh'
            const DEFAULT_VAL = '32vh';
            const MIN_VH = 20, MAX_VH = 80;

            function setVar(val){ body.style.setProperty('--commentsHeight', val); }
            function getVar(){ return body.style.getPropertyValue('--commentsHeight') || DEFAULT_VAL; }
            function vhToPx(vh){ return (parseFloat(vh) / 100) * window.innerHeight; }
            function pxToVh(px){ return (px / window.innerHeight) * 100; }
            function clampVhNum(n){ return Math.max(MIN_VH, Math.min(MAX_VH, n)); }
            function load(){ try { return localStorage.getItem(STORAGE_KEY) || DEFAULT_VAL; } catch { return DEFAULT_VAL; } }
            function save(v){ try { localStorage.setItem(STORAGE_KEY, v); } catch {} }

            // Apply stored value
            setVar(load());

            let dragging = false, startY = 0, startPx = 0, isTop = false, raf = null;
            function begin(e){
              if (body.classList.contains('hidden')) return;
              dragging = true; startY = e.clientY; isTop = (e.currentTarget === resizerTop);
              const cur = getVar();
              startPx = cur.endsWith('vh') ? vhToPx(cur) : parseFloat(cur) || body.getBoundingClientRect().height;
              try { e.currentTarget.setPointerCapture(e.pointerId); } catch {}
              document.body.classList.add('select-none'); document.body.style.cursor = 'row-resize';
              e.preventDefault();
            }
            function applyPx(px){
              const minPx = (MIN_VH/100)*window.innerHeight;
              const maxPx = (MAX_VH/100)*window.innerHeight;
              const clamped = Math.max(minPx, Math.min(maxPx, px));
              setVar(clamped + 'px');
              // UX tweak: when dragging top handle upwards, simulate content pulling by scrolling down
              if (isTop){
                try {
                  const list = document.getElementById('commentsList');
                  const content = document.getElementById('taskCommentsContent');
                  if (list && content){
                    const extra = Math.max(0, content.scrollHeight - content.clientHeight);
                    // Scroll by delta proportionally to growth to emulate pulling up
                    content.scrollTop = extra;
                  }
                } catch {}
              }
            }
            function move(e){
              if (!dragging) return;
              const delta = e.clientY - startY;
              const nextPx = startPx + (isTop ? -delta : delta);
              if (raf) cancelAnimationFrame(raf);
              raf = requestAnimationFrame(() => applyPx(nextPx));
            }
            function end(e){
              if (!dragging) return;
              dragging = false;
              document.body.classList.remove('select-none'); document.body.style.cursor = '';
              const cur = getVar();
              const px = cur.endsWith('vh') ? vhToPx(cur) : parseFloat(cur) || body.getBoundingClientRect().height;
              const vh = Math.round(clampVhNum(pxToVh(px)));
              const finalVal = vh + 'vh';
              setVar(finalVal); save(finalVal);
              try { e.currentTarget.releasePointerCapture(e.pointerId); } catch {}
            }

            resizerBottom.addEventListener('pointerdown', begin);
            resizerTop.addEventListener('pointerdown', begin);
            window.addEventListener('pointermove', move);
            window.addEventListener('pointerup', end);
            window.addEventListener('pointercancel', end);

            function onKeys(e){
              if (body.classList.contains('hidden')) return;
              const key = (e.key||'').toLowerCase();
              const top = (e.currentTarget === resizerTop);
              const STEP = 2, BIG = 8;
              const cur = getVar();
              let vh = cur.endsWith('vh') ? parseFloat(cur) : pxToVh(parseFloat(cur)||body.getBoundingClientRect().height);
              if (key === 'arrowup'){ e.preventDefault(); vh = clampVhNum(vh + (top ? STEP : -STEP)); }
              else if (key === 'arrowdown'){ e.preventDefault(); vh = clampVhNum(vh + (top ? -STEP : STEP)); }
              else if (key === 'pageup'){ e.preventDefault(); vh = clampVhNum(vh + (top ? BIG : -BIG)); }
              else if (key === 'pagedown'){ e.preventDefault(); vh = clampVhNum(vh + (top ? -BIG : BIG)); }
              else if (key === 'home'){ e.preventDefault(); vh = MIN_VH; }
              else if (key === 'end'){ e.preventDefault(); vh = MAX_VH; }
              else if (key === 'enter'){ e.preventDefault(); vh = 32; }
              else return;
              const val = Math.round(vh) + 'vh'; setVar(val); save(val);
            }
            resizerBottom.addEventListener('keydown', onKeys);
            resizerTop.addEventListener('keydown', onKeys);

            function sync(){ const d = body.classList.contains('hidden') ? 'none' : ''; resizerBottom.style.display = d; resizerTop.style.display = d; }
            sync(); toggle.addEventListener('click', () => setTimeout(sync, 0));

            window.addEventListener('resize', () => {
              const cur = getVar();
              const vh = cur.endsWith('vh') ? parseFloat(cur) : pxToVh(parseFloat(cur)||body.getBoundingClientRect().height);
              const val = Math.round(clampVhNum(vh)) + 'vh'; setVar(val); save(val);
            });

            // Fullscreen toggle
            const FS_KEY = 'sidebar.task.comments.fullscreen';
            function isFs(){ try { return localStorage.getItem(FS_KEY) === '1'; } catch { return false; } }
            function setFs(v){ try { localStorage.setItem(FS_KEY, v ? '1' : '0'); } catch {} }
            function applyFullscreen(state){
              const panel = document.getElementById('taskPanel');
              const block = document.getElementById('taskCommentsBlock');
              const sidebar = document.getElementById('sidebar');
              const resizer = document.getElementById('resizer');
              if (!panel || !block || !sidebar) return;
              const PREV_W_KEY = 'sidebar.prevWidthB4CommentsFs';
              if (state){
                // Hide everything except the comments block
                Array.from(panel.children).forEach(el => { if (el !== block) el.classList.add('hidden'); });
                // Maximize height
                setVar('calc(100vh - 140px)');
                // Maximize width to container limit
                try {
                  const container = (resizer && resizer.parentElement) ? resizer.parentElement : (sidebar.parentElement || document.body);
                  const containerWidth = container ? container.clientWidth : window.innerWidth;
                  const resizerWidth = resizer ? (resizer.offsetWidth || 0) : 0;
                  const maxSidebar = Math.max(260, containerWidth - resizerWidth);
                  const prevW = parseInt(sidebar.style.width || sidebar.offsetWidth || '384', 10);
                  localStorage.setItem(PREV_W_KEY, String(prevW));
                  sidebar.style.width = maxSidebar + 'px';
                  localStorage.setItem('sidebarWidth', String(maxSidebar));
                } catch {}
                if (btnFullscreen) btnFullscreen.textContent = 'Exit Fullscreen';
                try { cy.resize(); } catch {}
              } else {
                // Restore other blocks
                Array.from(panel.children).forEach(el => { if (el !== block) el.classList.remove('hidden'); });
                // Restore height and width
                setVar(load());
                try {
                  const prev = parseInt(localStorage.getItem(PREV_W_KEY) || '384', 10);
                  sidebar.style.width = prev + 'px';
                  localStorage.setItem('sidebarWidth', String(prev));
                } catch {}
                if (btnFullscreen) btnFullscreen.textContent = 'Fullscreen';
                try { cy.resize(); } catch {}
              }
            }
            if (btnFullscreen){
              btnFullscreen.addEventListener('click', () => { const ns = !isFs(); setFs(ns); applyFullscreen(ns); });
              applyFullscreen(isFs());
            }
          }
        })();
        function resetTabStyles(){
          tabTask.className = 'px-2 py-1 text-xs rounded bg-slate-200 text-slate-800';
          if (tabActions) tabActions.className = 'px-2 py-1 text-xs rounded bg-slate-200 text-slate-800';
          tabSettings.className = 'px-2 py-1 text-xs rounded bg-slate-200 text-slate-800';
        }
        function hideAllPanels(){
          taskPanel.classList.add('hidden');
          if (actionsPanel) actionsPanel.classList.add('hidden');
          settingsPanel.classList.add('hidden');
        }
        function showTask(){
          hideAllPanels();
          taskPanel.classList.remove('hidden');
          resetTabStyles();
          tabTask.className = 'px-2 py-1 text-xs rounded bg-slate-800 text-white';
          localStorage.setItem('sidebarTab', 'task');
          // Initialize Task Panel collapsible sections (idempotent)
          wireCollapsibleSection({ toggleId: 'taskSelectionLinkToggle', bodyId: 'taskSelectionLinkBody', storageKey: 'sidebar.task.selectionLink.collapsed', defaultCollapsed: false });
          wireCollapsibleSection({ toggleId: 'taskMetadataToggle', bodyId: 'taskMetadataBody', storageKey: 'sidebar.task.metadata.collapsed', defaultCollapsed: true });
          wireCollapsibleSection({ toggleId: 'taskStatusPriorityToggle', bodyId: 'taskStatusPriorityBody', storageKey: 'sidebar.task.statusPriority.collapsed', defaultCollapsed: false });
          wireCollapsibleSection({ toggleId: 'taskVisibilityToggle', bodyId: 'taskVisibilityBody', storageKey: 'sidebar.task.visibility.collapsed', defaultCollapsed: true });
          wireCollapsibleSection({ toggleId: 'taskCommentsToggle', bodyId: 'taskCommentsBody', storageKey: 'sidebar.task.comments.collapsed', defaultCollapsed: true });
          wireCollapsibleSection({ toggleId: 'taskHistoryToggle', bodyId: 'taskHistoryBody', storageKey: 'sidebar.task.history.collapsed', defaultCollapsed: true });
          wireCollapsibleSection({ toggleId: 'taskTimeToggle', bodyId: 'taskTimeBody', storageKey: 'sidebar.task.time.collapsed', defaultCollapsed: true });
          wireCollapsibleSection({ toggleId: 'taskCostsToggle', bodyId: 'taskCostsBody', storageKey: 'sidebar.task.costs.collapsed', defaultCollapsed: true });
          wireCollapsibleSection({ toggleId: 'taskDangerToggle', bodyId: 'taskDangerBody', storageKey: 'sidebar.task.danger.collapsed', defaultCollapsed: true });
          // Apply and wire reorder behavior
          applyPanelOrder(taskPanel, ORDER_KEYS.task, DEFAULT_TASK_IDS);
          wireReorderablePanel(taskPanel, ORDER_KEYS.task, DEFAULT_TASK_IDS);
          // Setup comments height resizer (idempotent)
          setupTaskCommentsResizer();
        }
        function showActions(){
          hideAllPanels();
          if (actionsPanel) actionsPanel.classList.remove('hidden');
          resetTabStyles();
          if (tabActions) tabActions.className = 'px-2 py-1 text-xs rounded bg-slate-800 text-white';
          localStorage.setItem('sidebarTab', 'actions');
        }
        function showSettings(){
          hideAllPanels();
          settingsPanel.classList.remove('hidden');
          resetTabStyles();
          tabSettings.className = 'px-2 py-1 text-xs rounded bg-slate-800 text-white';
          localStorage.setItem('sidebarTab', 'settings');
          // Initialize collapsible sections (idempotent)
          wireCollapsibleSection({ toggleId: 'serverInfoToggle', bodyId: 'serverInfoBody', storageKey: 'sidebar.settings.serverInfo.collapsed' });
          wireCollapsibleSection({ toggleId: 'envToggle', bodyId: 'envBody', storageKey: 'sidebar.settings.env.collapsed' });
          wireCollapsibleSection({ toggleId: 'exportImportToggle', bodyId: 'exportImportBody', storageKey: 'sidebar.settings.exportImport.collapsed' });
          wireCollapsibleSection({ toggleId: 'translationToggle', bodyId: 'translationBody', storageKey: 'sidebar.settings.translation.collapsed' });
          wireCollapsibleSection({ toggleId: 'visibilityToggle', bodyId: 'visibilityBody', storageKey: 'sidebar.settings.visibility.collapsed' });
          wireCollapsibleSection({ toggleId: 'zoomToggle', bodyId: 'zoomBody', storageKey: 'sidebar.settings.zoom.collapsed' });
          // Apply and wire reorder behavior
          applyPanelOrder(settingsPanel, ORDER_KEYS.settings, DEFAULT_SETTINGS_IDS);
          wireReorderablePanel(settingsPanel, ORDER_KEYS.settings, DEFAULT_SETTINGS_IDS);
          ensureSettingsLoaded();
        }
        tabTask.addEventListener('click', showTask);
        if (tabActions) tabActions.addEventListener('click', showActions);
        tabSettings.addEventListener('click', showSettings);
        // restore active tab
        const savedTab = localStorage.getItem('sidebarTab') || 'task';
        if (savedTab === 'settings') showSettings();
        else if (savedTab === 'actions') showActions();
        else showTask();

        // Settings: fetch and render
        async function ensureSettingsLoaded(){
          if (settingsLoaded) return;
          try {
            const r = await fetch('/api/v1/settings/env');
            if (!r.ok) throw new Error('Failed to load settings');
            const j = await r.json();
            const data = Array.isArray(j.data) ? j.data : [];
            const meta = j.meta || {};
            const tbody = document.getElementById('settingsTable');
            tbody.innerHTML = '';
            data.forEach(e => {
              const tr = document.createElement('tr');
              tr.setAttribute('data-key', e.key || '');
              const tdKey = document.createElement('td'); tdKey.className='px-3 py-2 align-top whitespace-nowrap font-mono text-slate-800';
              tdKey.textContent = e.key || '';
              if (e.is_sensitive){
                const badge = document.createElement('span');
                badge.className = 'ml-2 text-[10px] uppercase tracking-wide bg-rose-100 text-rose-700 rounded px-1 py-0.5';
                badge.textContent = 'sensitive';
                tdKey.appendChild(badge);
              }
              const tdVal = document.createElement('td'); tdVal.className='px-3 py-2 align-top';
              const val = document.createElement('div'); val.className='font-mono text-slate-800 break-all';
              val.setAttribute('data-real', e.value || '');
              val.setAttribute('data-masked', e.masked || '');
              val.setAttribute('data-state', 'masked');
              val.textContent = e.masked || '';
              tdVal.appendChild(val);
              const tdAct = document.createElement('td'); tdAct.className='px-3 py-2 align-top';
              const row = document.createElement('div'); row.className='flex items-center gap-2';
              const btnT = document.createElement('button'); btnT.className='px-2 py-1 text-xs rounded bg-slate-200 text-slate-800'; btnT.textContent='Show';
              btnT.addEventListener('click', ()=>{
                const state = val.getAttribute('data-state') || 'masked';
                if (state === 'masked'){ val.textContent = val.getAttribute('data-real') || ''; val.setAttribute('data-state','shown'); btnT.textContent='Hide'; }
                else { val.textContent = val.getAttribute('data-masked') || ''; val.setAttribute('data-state','masked'); btnT.textContent='Show'; }
              });
              const btnC = document.createElement('button'); btnC.className='px-2 py-1 text-xs rounded bg-slate-700 text-white'; btnC.textContent='Copy';
              btnC.addEventListener('click', async ()=>{
                try { await navigator.clipboard.writeText(val.getAttribute('data-real') || ''); btnC.textContent='Copied'; setTimeout(()=>btnC.textContent='Copy', 1200); }
                catch { btnC.textContent='Failed'; setTimeout(()=>btnC.textContent='Copy', 1200); }
              });
              row.appendChild(btnT); row.appendChild(btnC); tdAct.appendChild(row);
              tr.appendChild(tdKey); tr.appendChild(tdVal); tr.appendChild(tdAct);
              tbody.appendChild(tr);
            });
            const src = document.getElementById('settingsSource');
            if (src) src.textContent = meta.source || '';
            const alert = document.getElementById('settingsFallbackAlert');
            if (alert) {
              if (meta.fallback_used) { alert.textContent = '.env file not found. Displaying a limited subset from process environment.'; alert.classList.remove('hidden'); }
              else { alert.classList.add('hidden'); }
            }
            // filter
            const filter = document.getElementById('settingsFilter');
            filter.addEventListener('input', ()=>{
              const q = (filter.value || '').toLowerCase();
              Array.from(tbody.querySelectorAll('tr')).forEach(tr=>{
                const k = (tr.getAttribute('data-key') || '').toLowerCase();
                tr.style.display = (!q || k.includes(q)) ? '' : 'none';
              });
            });

            // restart button wiring inside project settings panel
            (function wireRestart(){
              function showBanner(msg, type){
                let el = document.getElementById('statusBanner');
                if (!el){ el = document.createElement('div'); el.id = 'statusBanner'; el.className = 'fixed top-3 left-1/2 -translate-x-1/2 px-3 py-1.5 rounded shadow text-sm'; document.body.appendChild(el); }
                const color = type === 'error' ? 'bg-rose-100 text-rose-800 border border-rose-200' : (type === 'success' ? 'bg-emerald-100 text-emerald-800 border border-emerald-200' : 'bg-sky-100 text-sky-800 border border-sky-200');
                el.className = 'fixed top-3 left-1/2 -translate-x-1/2 px-3 py-1.5 rounded shadow text-sm ' + color;
                el.textContent = msg;
                el.style.display = '';
              }
              function restartLog(msg){
                try {
                  let box = document.getElementById('restartDebug');
                  if (!box){
                    box = document.createElement('div');
                    box.id = 'restartDebug';
                    box.className = 'fixed bottom-3 right-3 max-w-md w-[28rem] max-h-52 overflow-auto bg-white/90 border border-slate-200 rounded shadow text-[12px] text-slate-800';
                    const head = document.createElement('div');
                    head.className = 'px-2 py-1 border-b bg-slate-50 flex items-center justify-between';
                    head.innerHTML = '<span class="font-medium">Restart Debug Log</span>';
                    const body = document.createElement('div'); body.id = 'restartDebugBody'; body.className = 'p-2 space-y-1';
                    box.appendChild(head); box.appendChild(body); document.body.appendChild(box);
                  }
                  const body = document.getElementById('restartDebugBody');
                  const line = document.createElement('div');
                  const ts = new Date();
                  const t = ts.toLocaleTimeString();
                  line.textContent = `[${t}] ${msg}`;
                  body.appendChild(line);
                  box.scrollTop = box.scrollHeight;
                } catch {}
              }
              const btn = document.getElementById('btnRestartInline');
              if (!btn) return;
              btn.addEventListener('click', async () => {
                if (!confirm('Restart the server now?')) return;
                showBanner('Restarting server...', 'info');
                restartLog('User clicked restart button');
                try {
                  // capture current pid
                  let oldPid = null;
                  try { const hh = await fetch('/api/v1/health', { cache: 'no-store' }).then(r=>r.json()); oldPid = hh && hh.data && hh.data.pid ? Number(hh.data.pid) : null; restartLog(`Fetched current health, oldPid=${oldPid??'null'}`); } catch { restartLog('Failed to fetch initial health'); }
                  const resp = await fetch('/api/v1/settings/restart', { method: 'POST' });
                  if (!resp.ok){ const t = await resp.text(); restartLog(`POST /settings/restart failed: ${String(t||resp.status)}`); showBanner('Failed to restart: ' + String(t||resp.status), 'error'); return; }
                  const jr = await resp.json();
                  const opId = jr && jr.data && jr.data.op_id ? String(jr.data.op_id) : '';
                  restartLog(`Received opId=${opId||'none'}`);
                  if (opId){ try { localStorage.setItem('lastRestartOpId', opId); } catch {} }
                  const downDeadline = Date.now() + 10000;
                  const upDeadline = Date.now() + 90000;
                  // wait for DOWN
                  while (Date.now() < downDeadline) {
                    try { const r = await fetch('/api/v1/health', { cache: 'no-store' }); if (!r.ok) { restartLog('Health is DOWN'); break; } else { restartLog('Waiting for DOWN...'); } } catch { restartLog('Health request threw, consider DOWN'); break; }
                    await new Promise(rs=>setTimeout(rs, 600));
                  }
                  // wait for UP and pid change
                  restartLog('Waiting for server to come UP...');
                  let lastStatusLogTs = 0;
                  while (Date.now() < upDeadline) {
                    if (opId){
                      try {
                        const s = await fetch('/api/v1/settings/restart/status/' + opId, { cache: 'no-store' }).then(r=>r.json());
                        if (s && s.data){
                          const nowTs = Date.now();
                          if (nowTs - lastStatusLogTs > 2000){ restartLog(`Status: ${String(s.data.status||'unknown')}`); lastStatusLogTs = nowTs; }
                        }
                        if (s && s.data && s.data.status === 'restarted'){
                          const pb = (s.data.pid_before != null) ? String(s.data.pid_before) : '';
                          const pa = (s.data.pid_after != null) ? String(s.data.pid_after) : '';
                          const hint = (pb && pa) ? ` (PID ${pb}\u2192${pa})` : '';
                          restartLog(`Status: restarted${hint}`);
                          showBanner('Server restarted' + hint + '. Reloading...', 'success');
                          setTimeout(()=>location.reload(), 800);
                          return;
                        }
                        if (s && s.data && s.data.status === 'port_still_in_use'){ restartLog('Status: port_still_in_use'); showBanner('Port still in use. Check logs.', 'error'); return; }
                      } catch {}
                    }
                    try {
                      const r = await fetch('/api/v1/health', { cache: 'no-store' });
                      if (r.ok){ const j = await r.json(); const np = j && j.data && j.data.pid ? Number(j.data.pid) : null; if (!oldPid || (np && np !== oldPid)) { const hint=(oldPid&&np)?` (PID ${oldPid}\u2192${np})`:''; restartLog(`Health UP, newPid=${np??'null'}${hint}`); showBanner('Server restarted'+hint+'. Reloading...', 'success'); setTimeout(()=>location.reload(), 800); return; } else { restartLog(`Health UP but PID unchanged (old=${oldPid??'null'}, new=${np??'null'})`); } }
                    } catch {}
                    await new Promise(rs=>setTimeout(rs, 1000));
                  }
                  restartLog('Timeout waiting for server to come UP');
                  showBanner('Server did not come back in time. Check logs.', 'error');
                } catch (e){ showBanner('Error: ' + String(e), 'error'); }
              });
            })();

            // server info loader
            (async function loadServerInfo(){
              try {
                const r = await fetch('/api/v1/health', { cache: 'no-store' });
                if (!r.ok) return;
                const j = await r.json();
                const d = j && j.data ? j.data : {};
                const pidEl = document.getElementById('server-pid'); if (pidEl) pidEl.textContent = (d.pid != null ? String(d.pid) : '—');
                const stEl = document.getElementById('server-start-time');
                const nowEl = document.getElementById('server-current-time');
                const upEl = document.getElementById('server-uptime');
                const lrEl = document.getElementById('server-last-restart');
                const fmt = (iso) => {
                  if (!iso) return '—';
                  try {
                    const dt = new Date(iso);
                    const mm = String(dt.getUTCMonth()+1).padStart(2,'0');
                    const dd = String(dt.getUTCDate()).padStart(2,'0');
                    const HH = String(dt.getUTCHours()).padStart(2,'0');
                    const MM = String(dt.getUTCMinutes()).padStart(2,'0');
                    const SS = String(dt.getUTCSeconds()).padStart(2,'0');
                    return `${mm}-${dd} ${HH}:${MM}:${SS}`;
                  } catch { return String(iso); }
                };
                // Set initial values
                const startedIso = d.started || null;
                if (stEl) stEl.textContent = fmt(startedIso);
                // Ticker to update Current and Uptime every second
                (function startTicker(){
                  const startedTs = startedIso ? Date.parse(startedIso) : null;
                  function formatNow(ts){
                    const dt = new Date(ts);
                    const mm = String(dt.getUTCMonth()+1).padStart(2,'0');
                    const dd = String(dt.getUTCDate()).padStart(2,'0');
                    const HH = String(dt.getUTCHours()).padStart(2,'0');
                    const MM = String(dt.getUTCMinutes()).padStart(2,'0');
                    const SS = String(dt.getUTCSeconds()).padStart(2,'0');
                    return `${mm}-${dd} ${HH}:${MM}:${SS}`;
                  }
                  function tick(){
                    const nowTs = Date.now();
                    if (nowEl) nowEl.textContent = formatNow(nowTs);
                    if (upEl){
                      if (startedTs){
                        const s = Math.max(0, Math.floor((nowTs - startedTs)/1000));
                        const days = Math.floor(s/86400);
                        const h = Math.floor((s%86400)/3600).toString().padStart(2,'0');
                        const m = Math.floor((s%3600)/60).toString().padStart(2,'0');
                        const sec = Math.floor(s%60).toString().padStart(2,'0');
                        upEl.textContent = `${days} days, ${h}:${m}:${sec}`;
                      } else {
                        upEl.textContent = '—';
                      }
                    }
                  }
                  tick();
                  setInterval(tick, 1000);
                })();
                
                // Last restart info using opId from localStorage
                try {
                  const opId = localStorage.getItem('lastRestartOpId') || '';
                  if (opId && lrEl){
                    const s = await fetch('/api/v1/settings/restart/status/' + opId, { cache: 'no-store' }).then(r=>r.json()).catch(()=>null);
                    const data = s && s.data;
                    if (data && data.status === 'restarted' && (data.pid_before!=null || data.pid_after!=null)){
                      const pb = data.pid_before!=null ? String(data.pid_before) : '';
                      const pa = data.pid_after!=null ? String(data.pid_after) : '';
                      lrEl.textContent = (pb && pa) ? `PID ${pb}→${pa}` : '—';
                    }
                  }
                } catch {}
              } catch {}
            })();
            settingsLoaded = true;
          } catch (e) {
            const tbody = document.getElementById('settingsTable');
            if (tbody) { tbody.innerHTML = '<tr><td class="px-3 py-2 text-rose-700" colspan="3">Failed to load settings</td></tr>'; }
          }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          const tag = e.target && e.target.tagName;
          const isEditable = (e.target && (e.target.isContentEditable || tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT'));
          if (isEditable) return;
          const k = (e.key || '').toLowerCase();
          // D = delete edge when edge selected
          if (k === 'd' && selectedEdgeId && !selectedNodeId) { e.preventDefault(); deleteSelectedEdge(); return; }
          if (k === 'n') { e.preventDefault(); document.getElementById('btnAddNode').click(); return; }
          if (k === 'e') { e.preventDefault(); document.getElementById('btnAddEdge').click(); return; }
          if (k === 'f') { e.preventDefault(); document.getElementById('btnFit').click(); return; }
          if (e.key === 'Delete') {
            e.preventDefault();
            if (selectedNodeId) { document.getElementById('btnDeleteNodePanel').click(); }
            else if (selectedEdgeId) { deleteSelectedEdge(); }
            return;
          }
          if (k === '/') { e.preventDefault(); document.getElementById('searchBox').focus(); return; }
        });

        // Inline rename project by editing title
        const projTitleEl = document.getElementById('projTitle');
        async function commitProjectTitle(){
          const name = (projTitleEl.textContent || '').trim();
          if (!name) return;
          try {
            const resp = await patchJSON(`/api/v1/projects/${projectId}`, { name });
            document.title = `${resp.data.name} - Graph`;
            projTitleEl.textContent = resp.data.name;
          } catch(e) { /* ignore */ }
        }
        projTitleEl.addEventListener('keydown', (e)=>{ if (e.key==='Enter'){ e.preventDefault(); projTitleEl.blur(); }});
        projTitleEl.addEventListener('blur', commitProjectTitle);

        // Helpers: export/import and translation API
        async function exportProjectJSON(pid){
          const nodes = await fetch(`/api/v1/projects/${pid}/nodes`).then(r=>r.json());
          const edges = await fetch(`/api/v1/projects/${pid}/edges`).then(r=>r.json());
          const blob = new Blob([JSON.stringify({nodes: nodes.data, edges: edges.data}, null, 2)], {type: 'application/json'});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = `project-${pid}.json`; a.click();
          URL.revokeObjectURL(url);
        }

        async function importProjectJSONFromFile(file){
          const text = await file.text();
          const data = JSON.parse(text);
          for (const n of (data.nodes || [])) {
            await postJSON(`/api/v1/projects/${projectId}/nodes`, { title: n.title || n.id, description: n.description || '', link_url: (n.link_url || null) });
          }
          // reload graph after import to get IDs and edges correct
          const curLang = getCurrentLang();
          graph = await fetchGraph(curLang);
          cy.elements().remove();
          cy.add(toElements(graph));
          cy.layout({ name: 'preset' }).run();
          cy.fit();
        }

        async function fetchTranslationStats(lang){
          return await fetch(`/api/v1/projects/${projectId}/translation/stats?lang=${encodeURIComponent(lang||'en')}`).then(r=>r.json());
        }

        async function runTranslateAsync(lang, opts){
          const body = Object.assign({ lang: (lang||'en'), include_nodes: true, include_comments: false, stale: false, force: false }, (opts||{}));
          return await fetch(`/api/v1/projects/${projectId}/translate/async`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) }).then(r=>r.json());
        }

        // Export JSON (nodes+edges)
        try { document.getElementById('btnExportJSON').addEventListener('click', async () => { exportProjectJSON(projectId); }); } catch {}

        // Import JSON (append)
        try { document.getElementById('importInput').addEventListener('change', async (e) => {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          await importProjectJSONFromFile(file);
          e.target.value = '';
        }); } catch {}

        // Screenshot PNG
        document.getElementById('btnScreenshot').addEventListener('click', () => {
          const png = cy.png({full: true, scale: 2});
          const a = document.createElement('a');
          a.href = png; a.download = `graph-${projectId}.png`; a.click();
        });

        // Onboarding overlay
        const help = document.getElementById('btnHelp');
        help.addEventListener('click', () => {
          alert('Shortcuts: n=new node, e=new edge, f=fit, /=search. Ctrl+Click a node with Link URL opens it in a new tab. Use toolbar to manage nodes/edges, sidebar for comments/time/cost.');
        });

        // Persist position after drag
        cy.on('dragfree', 'node', async (evt) => {
          const n = evt.target;
          const p = n.position();
          try {
            await postJSON(`/api/v1/nodes/${n.id()}/position`, { x: p.x, y: p.y });
            n.data('savedX', p.x);
            n.data('savedY', p.y);
          } catch (e) { /* ignore */ }
        });

        // (removed) toolbar Show hidden wiring; handled in Settings block

        // Settings: wire Export/Import controls
        (function wireSettingsExportImport(){
          const btnExp = document.getElementById('settingsBtnExportJSON');
          if (btnExp) btnExp.addEventListener('click', () => { exportProjectJSON(projectId); showToast('Exported project JSON', 'success'); });
          const inp = document.getElementById('settingsImportInput');
          if (inp) inp.addEventListener('change', async (e)=>{ const file = e.target.files && e.target.files[0]; if (!file) return; await importProjectJSONFromFile(file); showToast('Import completed', 'success'); e.target.value=''; });
        })();

        // Settings: wire Language select and sync with toolbar
        (function wireSettingsLanguage(){
          const sSel = document.getElementById('settingsLangSelect');
          if (!sSel) return;
          // initialize from saved
          const saved = localStorage.getItem('displayLang') || '';
          sSel.value = saved;
          sSel.addEventListener('change', async (e)=>{ const lang = e.target.value || ''; await handleLanguageChange(lang); });
        })();

        // Settings: wire Show Hidden checkbox and sync with toolbar
        (function wireSettingsShowHidden(){
          const chkSettings = document.getElementById('settingsShowHiddenToggle');
          if (!chkSettings) return;
          // restore saved
          const saved = localStorage.getItem('showHidden');
          if (saved !== null) chkSettings.checked = (saved === '1');
          chkSettings.addEventListener('change', async ()=>{
            localStorage.setItem('showHidden', chkSettings.checked ? '1' : '0');
            const lang = getCurrentLang();
            graph = await fetchGraph(lang);
            cy.elements().remove();
            cy.add(toElements(graph));
            cy.layout({ name: 'preset' }).run();
            cy.fit();
            try { recomputePriorityPaths(); } catch {}
          });
        })();

        // Settings: wire Translation Stats and Run Translate
        (function wireSettingsTranslationActions(){
          const statsBtn = document.getElementById('settingsBtnTrStats');
          const runBtn = document.getElementById('settingsBtnRunTranslate');
          const outStats = document.getElementById('settingsTrStats');
          const outJob = document.getElementById('settingsTrJob');
          function curLang(){
            const a = document.getElementById('settingsLangSelect');
            const b = document.getElementById('langSelect');
            return (a && a.value) || (b && b.value) || 'en';
          }
          if (statsBtn){
            statsBtn.addEventListener('click', async ()=>{
              const lang = curLang();
              statsBtn.disabled = true; statsBtn.setAttribute('aria-busy','true');
              try {
                const s = await fetchTranslationStats(lang);
                const d = (s && s.data) || {};
                outStats.textContent = `Language: ${lang}\nMissing nodes: ${d.missing_nodes}\nStale nodes: ${d.stale_nodes}\nMissing comments: ${d.missing_comments}\nStale comments: ${d.stale_comments}`;
              } catch { outStats.textContent = 'Failed to load translation stats'; showToast('Failed to load translation stats','error'); }
              finally { statsBtn.disabled = false; statsBtn.removeAttribute('aria-busy'); }
            });
          }
          if (runBtn){
            runBtn.addEventListener('click', async ()=>{
              const lang = curLang();
              const old = runBtn.textContent; runBtn.disabled = true; runBtn.textContent = 'Running...'; runBtn.setAttribute('aria-busy','true');
              try {
                const res = await runTranslateAsync(lang);
                const jobId = res && res.data && res.data.job_id;
                outJob.textContent = jobId ? `Started translate job: ${jobId}` : 'Started translate job';
              } catch { outJob.textContent = 'Failed to start translate job'; showToast('Failed to start translate job','error'); }
              finally { runBtn.disabled = false; runBtn.textContent = old; runBtn.removeAttribute('aria-busy'); }
            });
          }
        })();

        // Actions panel: mirror header actions with shared handlers
        (function wireActionsPanel(){
          try {
            // Single-column layout
            const list = document.querySelector('#actionsMainBlock .flex');
            if (list) list.className = 'flex flex-col gap-2';

            // Registry for visibility control
            const ACTIONS = [
              { headerId: 'btnAddNode', panelId: 'btnAddNodePanel', storageKey: 'actions.header.show.btnAddNode', defaultShow: true },
              { headerId: 'btnAddEdge', panelId: 'btnAddEdgePanel', storageKey: 'actions.header.show.btnAddEdge', defaultShow: true },
              { headerId: 'btnCriticalPath', panelId: 'btnCriticalPathPanel', storageKey: 'actions.header.show.btnCriticalPath', defaultShow: true },
              { headerId: 'btnFit', panelId: 'btnFitPanel', storageKey: 'actions.header.show.btnFit', defaultShow: true },
              { headerId: 'btnResetView', panelId: 'btnResetViewPanel', storageKey: 'actions.header.show.btnResetView', defaultShow: true },
              { headerId: 'btnGroup', panelId: 'btnGroupPanel', storageKey: 'actions.header.show.btnGroup', defaultShow: true },
              { headerId: 'btnUngroup', panelId: 'btnUngroupPanel', storageKey: 'actions.header.show.btnUngroup', defaultShow: true },
              { headerId: 'btnCollapse', panelId: 'btnCollapsePanel', storageKey: 'actions.header.show.btnCollapse', defaultShow: true },
              { headerId: 'btnExpand', panelId: 'btnExpandPanel', storageKey: 'actions.header.show.btnExpand', defaultShow: true },
              { headerId: 'btnScreenshot', panelId: 'btnScreenshotPanel', storageKey: 'actions.header.show.btnScreenshot', defaultShow: true },
            ];
            const isShownInHeader = (key, def) => { try { const v = localStorage.getItem(key); if (v==='1') return true; if (v==='0') return false; } catch {} return !!def; };
            const setShownInHeader = (key, on) => { try { localStorage.setItem(key, on ? '1' : '0'); } catch {} };
            const applyHeaderVisibility = () => {
              ACTIONS.forEach(a => {
                const el = document.getElementById(a.headerId);
                if (!el) return;
                const show = isShownInHeader(a.storageKey, a.defaultShow);
                if (show) el.classList.remove('hidden'); else el.classList.add('hidden');
              });
            };
            const resetHeaderVisibilityToDefaults = () => {
              ACTIONS.forEach(a => { setShownInHeader(a.storageKey, !!a.defaultShow); });
              applyHeaderVisibility();
              // sync checkboxes UI
              ACTIONS.forEach(a => {
                const btn = document.getElementById(a.panelId);
                if (!btn) return;
                const row = btn.parentElement;
                const chk = row && row.querySelector('input[type="checkbox"]');
                if (chk) chk.checked = !!a.defaultShow;
              });
            };

            // Wrap each row with a checkbox
            ACTIONS.forEach(a => {
              const btn = document.getElementById(a.panelId);
              if (!btn || btn.dataset.rowWired === '1') return;
              btn.dataset.rowWired = '1';
              if (!btn.className.includes('w-full')) btn.className += ' w-full';
              const row = document.createElement('div'); row.className = 'flex items-center gap-2';
              const spacer = document.createElement('div'); spacer.className = 'flex-1';
              const lab = document.createElement('label'); lab.className = 'inline-flex items-center gap-2 text-xs text-slate-600 whitespace-nowrap';
              const chk = document.createElement('input'); chk.type = 'checkbox'; chk.checked = isShownInHeader(a.storageKey, a.defaultShow); chk.setAttribute('aria-label','Show in header');
              const cap = document.createElement('span'); cap.textContent = 'Show in header';
              lab.appendChild(chk); lab.appendChild(cap);
              btn.parentElement.insertBefore(row, btn);
              row.appendChild(btn); row.appendChild(spacer); row.appendChild(lab);
              chk.addEventListener('change', () => { setShownInHeader(a.storageKey, !!chk.checked); applyHeaderVisibility(); });
            });

            // Initial visibility sync
            applyHeaderVisibility();

            // Reset to defaults
            const resetBtn = document.getElementById('btnActionsResetVisibility');
            if (resetBtn && resetBtn.dataset.wired !== '1'){
              resetBtn.dataset.wired = '1';
              resetBtn.addEventListener('click', resetHeaderVisibilityToDefaults);
            }

            // Mirror handlers
            const addNodeP = document.getElementById('btnAddNodePanel'); if (addNodeP && addNodeP.dataset.wired !== '1') { addNodeP.dataset.wired='1'; addNodeP.addEventListener('click', ()=> { const b=document.getElementById('btnAddNode'); if (b) b.click(); }); }
            const addEdgeP = document.getElementById('btnAddEdgePanel'); if (addEdgeP && addEdgeP.dataset.wired !== '1') { addEdgeP.dataset.wired='1'; addEdgeP.addEventListener('click', ()=> { const b=document.getElementById('btnAddEdge'); if (b) b.click(); }); }
            const cpP = document.getElementById('btnCriticalPathPanel'); if (cpP && cpP.dataset.wired !== '1') { cpP.dataset.wired='1'; cpP.addEventListener('click', ()=> { const b=document.getElementById('btnCriticalPath'); if (b) b.click(); }); }
            const fitP = document.getElementById('btnFitPanel'); if (fitP && fitP.dataset.wired !== '1') { fitP.dataset.wired='1'; fitP.addEventListener('click', ()=> { try { cy.fit(); } catch {} }); }
            const resetP = document.getElementById('btnResetViewPanel'); if (resetP && resetP.dataset.wired !== '1') { resetP.dataset.wired='1'; resetP.addEventListener('click', ()=> { try { showAllAndFit(); } catch {} }); }
            const groupP = document.getElementById('btnGroupPanel'); if (groupP && groupP.dataset.wired !== '1') { groupP.dataset.wired='1'; groupP.addEventListener('click', ()=> { const b=document.getElementById('btnGroup'); if (b) b.click(); }); }
            const ungroupP = document.getElementById('btnUngroupPanel'); if (ungroupP && ungroupP.dataset.wired !== '1') { ungroupP.dataset.wired='1'; ungroupP.addEventListener('click', ()=> { const b=document.getElementById('btnUngroup'); if (b) b.click(); }); }
            const collapseP = document.getElementById('btnCollapsePanel'); if (collapseP && collapseP.dataset.wired !== '1') { collapseP.dataset.wired='1'; collapseP.addEventListener('click', ()=> { const b=document.getElementById('btnCollapse'); if (b) b.click(); }); }
            const expandP = document.getElementById('btnExpandPanel'); if (expandP && expandP.dataset.wired !== '1') { expandP.dataset.wired='1'; expandP.addEventListener('click', ()=> { const b=document.getElementById('btnExpand'); if (b) b.click(); }); }
            const shotP = document.getElementById('btnScreenshotPanel'); if (shotP && shotP.dataset.wired !== '1') { shotP.dataset.wired='1'; shotP.addEventListener('click', ()=> { const b=document.getElementById('btnScreenshot'); if (b) b.click(); }); }
          } catch {}
        })();
      })();
    </script>
  </body>
  </html>

