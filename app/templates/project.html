<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>{{ project.name }} - Graph</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
  </head>
  <body class="min-h-screen bg-slate-50 text-slate-900">
    <div class="flex flex-col h-screen">
      <div class="flex items-center justify-between px-4 py-3">
        <h1 id="projTitle" class="text-2xl font-semibold cursor-text" contenteditable="true" spellcheck="false">{{ project.name }}</h1>
        <div class="flex items-center gap-3">
          <span id="userEmail" class="text-sm text-slate-600 hidden"></span>
          <button id="btnLogin" class="px-3 py-1 bg-slate-700 text-white rounded">Login</button>
          <button id="btnLogout" class="px-3 py-1 bg-slate-500 text-white rounded hidden">Logout</button>
          <a class="text-blue-600 underline" href="/">Home</a>
        </div>
      </div>

      <div class="flex flex-1 overflow-hidden">
        <div class="flex-1 flex flex-col min-w-0">
          <div class="px-4 pb-3 flex flex-wrap gap-2 items-center">
            <input id="searchBox" type="text" placeholder="Search nodes..." class="border rounded px-2 py-1" />
            <select id="statusFilter" class="border rounded px-2 py-1">
              <option value="">All</option>
              <option value="planned">Todo</option>
              <option value="in-progress">In Progress</option>
              <option value="done">Done</option>
              <option value="blocked">Blocked</option>
            </select>
            <button id="btnAddNode" class="px-3 py-1 bg-blue-600 text-white rounded">+ Node</button>
            <button id="btnAddEdge" class="px-3 py-1 bg-indigo-600 text-white rounded">+ Edge</button>
            <button id="btnCriticalPath" class="px-3 py-1 bg-teal-600 text-white rounded">Critical Path</button>
            <button id="btnGroup" class="px-3 py-1 bg-purple-600 text-white rounded">Group</button>
            <button id="btnUngroup" class="px-3 py-1 bg-purple-500 text-white rounded">Ungroup</button>
            <button id="btnCollapse" class="px-3 py-1 bg-fuchsia-600 text-white rounded">Collapse</button>
            <button id="btnExpand" class="px-3 py-1 bg-fuchsia-500 text-white rounded">Expand</button>
            <button id="btnFit" class="px-3 py-1 bg-slate-600 text-white rounded">Fit</button>
            <button id="btnExportJSON" class="px-3 py-1 bg-slate-700 text-white rounded">Export JSON</button>
            <label class="px-3 py-1 bg-slate-700 text-white rounded cursor-pointer">Import JSON<input id="importInput" type="file" accept="application/json" class="hidden" /></label>
            <button id="btnScreenshot" class="px-3 py-1 bg-slate-700 text-white rounded">Screenshot</button>
            <button id="btnHelp" class="px-3 py-1 bg-slate-500 text-white rounded">Help</button>
            <select id="langSelect" class="ml-2 border rounded px-2 py-1">
              <option value="">Original</option>
              <option value="en">English</option>
            </select>
            <button id="btnTrStats" class="px-3 py-1 bg-slate-200 text-slate-800 rounded">Translation Stats</button>
            <button id="btnTrRun" class="px-3 py-1 bg-indigo-600 text-white rounded">Run Translate</button>
            <button id="btnResetView" class="px-3 py-1 bg-slate-200 text-slate-800 rounded">Reset View</button>
            <button id="btnToggleSidebar" class="ml-auto px-3 py-1 bg-slate-200 text-slate-800 rounded">Toggle Sidebar</button>
          </div>
          <div class="relative flex-1 min-h-0 mx-4 mb-4">
            <div id="cy" class="absolute inset-0 bg-white rounded shadow z-0 pointer-events-auto"></div>
            <div class="absolute right-3 bottom-3 flex flex-col gap-2 z-30 pointer-events-auto">
              <button id="zoomIn" class="w-10 h-10 rounded bg-white/90 shadow text-xl">+</button>
              <button id="zoomOut" class="w-10 h-10 rounded bg-white/90 shadow text-xl">−</button>
            </div>
          </div>
        </div>
        <div id="resizer" class="w-1 cursor-col-resize bg-slate-200"></div>
        <aside id="sidebar" class="bg-white rounded-l-none rounded shadow p-4 space-y-4 overflow-auto" style="width: 384px;">
          <div class="flex items-center gap-2 mb-1">
            <button id="tabTask" class="px-2 py-1 text-xs rounded bg-slate-800 text-white">Task</button>
            <button id="tabSettings" class="px-2 py-1 text-xs rounded bg-slate-200 text-slate-800">Settings</button>
          </div>
          <div id="taskPanel" class="space-y-4">
          <h2 class="font-medium">Task Panel</h2>
          <div>
            <label class="block text-sm text-slate-600">Selected Node Title</label>
            <div id="selNodeTitle" contenteditable="true" spellcheck="false" class="text-sm text-slate-800 truncate border rounded px-2 py-1 focus:outline-none focus:ring focus:ring-slate-300">—</div>
          </div>
          <div>
            <label class="block text-sm text-slate-600">Translated Title (preview)</label>
            <div class="flex gap-2 items-center">
              <input id="selNodeTitleTranslated" class="flex-1 text-sm border rounded px-2 py-1" placeholder="—" readonly />
              <button id="btnRefreshTranslation" class="px-2 py-1 text-xs bg-slate-200 rounded">Refresh</button>
            </div>
          </div>
          <div>
            <label class="block text-sm text-slate-600">Selected Node ID</label>
            <div id="selNode" class="text-sm font-mono text-slate-800">—</div>
          </div>
          <div>
            <label class="block text-sm text-slate-600">Created At</label>
            <div id="createdAt" class="text-sm text-slate-800">—</div>
          </div>
          <div>
            <label class="block text-sm">Status</label>
            <select id="statusSelect" class="w-full border rounded p-2">
              <option value="planned">todo</option>
              <option value="in-progress">in-progress</option>
              <option value="done">done</option>
              <option value="blocked">blocked</option>
            </select>
          </div>
          <div>
            <label class="block text-sm">Priority</label>
            <select id="prioritySelect" class="w-full border rounded p-2">
              <option value="low">low</option>
              <option value="normal" selected>normal</option>
              <option value="high">high</option>
              <option value="critical">critical</option>
            </select>
          </div>
          <div>
            <label class="block text-sm text-slate-600">Descendants (via edges)</label>
            <div id="descCount" class="text-sm text-slate-800">0</div>
          </div>
          <div>
            <h3 class="text-sm font-semibold">Comments</h3>
            <ul id="commentsList" class="text-sm space-y-1 max-h-32 overflow-auto"></ul>
          </div>
          <div>
            <h3 class="text-sm font-semibold">Status History</h3>
            <ul id="statusHistory" class="text-sm space-y-1 max-h-24 overflow-auto"></ul>
          </div>
          <form id="commentForm" class="space-y-2">
            <div>
              <label class="block text-sm">Comment</label>
              <textarea name="body" class="w-full border rounded p-2" rows="3" placeholder="Write a comment"></textarea>
            </div>
            <input type="hidden" name="user_id" value="system-user" />
            <button type="submit" class="px-3 py-1 bg-blue-600 text-white rounded">Add Comment</button>
          </form>
          <div>
            <h3 class="text-sm font-semibold">Time</h3>
            <ul id="timeList" class="text-sm space-y-1 max-h-24 overflow-auto"></ul>
          </div>
          <form id="timeForm" class="space-y-2">
            <div>
              <label class="block text-sm">Hours</label>
              <input name="hours" type="number" step="0.1" class="w-full border rounded p-2" placeholder="1.0" />
            </div>
            <input type="hidden" name="user_id" value="system-user" />
            <button type="submit" class="px-3 py-1 bg-emerald-600 text-white rounded">Add Time</button>
          </form>
          <div>
            <h3 class="text-sm font-semibold">Costs</h3>
            <ul id="costList" class="text-sm space-y-1 max-h-24 overflow-auto"></ul>
          </div>
          <form id="costForm" class="space-y-2">
            <div>
              <label class="block text-sm">Amount</label>
              <input name="amount" type="number" step="0.01" class="w-full border rounded p-2" placeholder="100" />
            </div>
            <button type="submit" class="px-3 py-1 bg-amber-600 text-white rounded">Add Cost</button>
          </form>
          <div>
            <button id="btnDeleteNodePanel" class="w-full mt-2 px-3 py-2 bg-rose-600 text-white rounded hidden">Delete Node</button>
          </div>
          </div>

          <div id="settingsPanel" class="space-y-3 hidden">
            <div class="flex items-center justify-between">
              <h3 class="font-medium">Settings</h3>
              <span id="settingsSource" class="text-xs text-slate-500"></span>
            </div>
            <input id="settingsFilter" type="text" placeholder="Filter by key..." class="w-full border rounded px-2 py-1" />
            <div id="settingsFallbackAlert" class="hidden text-sm text-amber-800 bg-amber-50 border border-amber-200 rounded p-2"></div>
            <div class="overflow-auto rounded border">
              <table class="min-w-full text-sm">
                <thead class="bg-slate-100 text-slate-700">
                  <tr>
                    <th class="text-left px-3 py-2 font-medium">Key</th>
                    <th class="text-left px-3 py-2 font-medium">Value</th>
                    <th class="text-left px-3 py-2 font-medium">Actions</th>
                  </tr>
                </thead>
                <tbody id="settingsTable" class="divide-y"></tbody>
              </table>
            </div>
          </div>
        </aside>
      </div>
    </div>

    <script>
      const projectId = "{{ project.id }}";

      function formatDate(iso) {
        if (!iso) return '—';
        const d = new Date(iso);
        if (isNaN(d.getTime())) return String(iso);
        try {
          const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
          const base = new Intl.DateTimeFormat(navigator.language || 'en-US', {
            year: 'numeric', month: 'short', day: '2-digit',
            hour: '2-digit', minute: '2-digit', hour12: false,
            timeZoneName: 'short'
          }).format(d);
          return `${base} (${tz})`;
        } catch { return d.toLocaleString(); }
      }

      async function apiMe(){
        const r = await fetch('/api/v1/auth/me');
        const j = await r.json();
        return j && j.data;
      }
      async function apiLogin(email, password){
        const r = await fetch('/api/v1/auth/login', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({email, password})});
        if (!r.ok) throw new Error('Login failed');
        return r.json();
      }
      async function apiLogout(){ await fetch('/api/v1/auth/logout', {method:'POST'}); }

      function wireAuthHeader(){
        const emailEl = document.getElementById('userEmail');
        const btnLogin = document.getElementById('btnLogin');
        const btnLogout = document.getElementById('btnLogout');
        async function refresh(){
          const me = await apiMe();
          if (me && me.id){
            emailEl.textContent = me.id;
            emailEl.classList.remove('hidden');
            btnLogout.classList.remove('hidden');
            btnLogin.classList.add('hidden');
          } else {
            emailEl.classList.add('hidden');
            btnLogout.classList.add('hidden');
            btnLogin.classList.remove('hidden');
          }
        }
        btnLogin.addEventListener('click', async ()=>{
          const email = prompt('Email');
          const password = prompt('Password');
          if (!email || !password) return;
          try { await apiLogin(email, password); } catch { alert('Invalid credentials'); }
          refresh();
        });
        btnLogout.addEventListener('click', async ()=>{ await apiLogout(); refresh(); });
        refresh();
      }

      async function fetchGraph(lang="") {
        const q = lang ? `?lang=${encodeURIComponent(lang)}` : "";
        const [nodesRes, edgesRes] = await Promise.all([
          fetch(`/api/v1/projects/${projectId}/nodes${q}`),
          fetch(`/api/v1/projects/${projectId}/edges`),
        ]);
        const nodesJson = await nodesRes.json();
        const edgesJson = await edgesRes.json();
        return { nodes: nodesJson.data, edges: edgesJson.data };
      }

      function toElements(graph) {
        const dotIcon = 'data:image/svg+xml;utf8,' + encodeURIComponent(
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">\
            <circle cx="25" cy="25" r="12" fill="#0f172a"/>\
            <circle cx="75" cy="25" r="12" fill="#0f172a"/>\
            <circle cx="25" cy="75" r="12" fill="#0f172a"/>\
            <circle cx="75" cy="75" r="12" fill="#0f172a"/>\
            <circle cx="50" cy="50" r="12" fill="#0f172a"/>\
          </svg>'
        );
        const nodes = graph.nodes.map(n => ({
          data: {
            id: String(n.id),
            label: (n.title_translated || n.title),
            score: n.importance_score,
            status: n.status,
            is_group: !!n.is_group,
            parent: (n.parent_id !== null && n.parent_id !== undefined) ? String(n.parent_id) : undefined,
            dotIcon: dotIcon,
            savedX: (n.position && typeof n.position.x === 'number') ? n.position.x : null,
            savedY: (n.position && typeof n.position.y === 'number') ? n.position.y : null,
            created_at: n.created_at,
            priority: (n.priority || 'normal'),
            descendants: 0
          },
          position: n.position
        }));
        const prioById = new Map(nodes.map(ne => [ne.data.id, ne.data.priority]));
        const statusById = new Map(nodes.map(ne => [ne.data.id, ne.data.status]));
        const edges = graph.edges.map(e => ({ data: { id: String(e.id), source: String(e.source_node_id), target: String(e.target_node_id), type: e.type, weight: e.weight, targetPriority: prioById.get(String(e.target_node_id)) || 'normal', targetStatus: statusById.get(String(e.target_node_id)) || 'planned', pathPriority: 'none' }}));
        // compute descendants counts on client (outgoing reachability) and priority paths
        const idToNode = new Map();
        nodes.forEach(n => idToNode.set(n.data.id, n));
        const adj = new Map();
        nodes.forEach(n => adj.set(n.data.id, []));
        graph.edges.forEach(e => { const a = adj.get(String(e.source_node_id)); if (a) a.push(String(e.target_node_id)); });
        function countDesc(start){
          const visited = new Set([start]);
          const q = [start];
          let c = 0;
          while (q.length){
            const cur = q.shift();
            (adj.get(cur) || []).forEach(t => { if (!visited.has(t)) { visited.add(t); q.push(t); c++; } });
          }
          return c;
        }
        nodes.forEach(n => { n.data.descendants = countDesc(n.data.id); });
        // mark edges on any path to high/critical (not done) targets
        const incoming = new Map(); nodes.forEach(n=>incoming.set(n.data.id, []));
        graph.edges.forEach(e => { (incoming.get(String(e.target_node_id))||[]).push(String(e.source_node_id)); });
        const pathPrio = new Map(graph.edges.map(e=>[String(e.id), 'none']));
        const queue = [];
        nodes.forEach(n => {
          const pr = n.data.priority || 'normal';
          const st = n.data.status || 'planned';
          if ((pr==='high' || pr==='critical') && st!=='done') queue.push(n.data.id);
        });
        while (queue.length){
          const tgt = queue.shift();
          const preds = incoming.get(tgt) || [];
          preds.forEach(src => {
            const edge = graph.edges.find(e => String(e.source_node_id)===src && String(e.target_node_id)===tgt);
            if (edge){
              const pr = prioById.get(tgt) || 'normal';
              const key = String(edge.id);
              const desired = (pr==='critical') ? 'critical' : (pr==='high' ? 'high' : 'none');
              if (desired!=='none' && pathPrio.get(key)!==desired){
                pathPrio.set(key, desired);
                queue.push(src);
              }
            }
          });
        }
        edges.forEach(e => { e.data.pathPriority = pathPrio.get(e.data.id) || 'none'; });
        return [...nodes, ...edges];
      }

      (async function init() {
        wireAuthHeader();
        const savedLang = localStorage.getItem('displayLang') || '';
        let graph = await fetchGraph(savedLang);
        const allHavePositions = Array.isArray(graph.nodes) && graph.nodes.length > 0 && graph.nodes.every(n => n.position && typeof n.position.x === 'number' && typeof n.position.y === 'number');
        const cy = cytoscape({
          container: document.getElementById('cy'),
          elements: toElements(graph),
          style: [
            { selector: 'node', style: { 'label': 'data(label)', 'text-valign': 'center', 'color': '#0f172a', 'background-color': '#38bdf8', 'width': 'mapData(descendants, 0, 20, 20, 80)', 'height': 'mapData(descendants, 0, 20, 20, 80)'} },
            { selector: 'edge', style: { 'line-color': '#64748b', 'width': 1.5, 'curve-style': 'bezier', 'target-arrow-color': '#64748b', 'target-arrow-shape': 'triangle', 'arrow-scale': 1.2 } },
            { selector: 'edge[pathPriority = "high"]', style: { 'line-color': '#f59e0b', 'target-arrow-color': '#f59e0b' } },
            { selector: 'edge[pathPriority = "critical"]', style: { 'line-color': '#ef4444', 'target-arrow-color': '#ef4444' } },
            { selector: 'edge[targetPriority = "high"][targetStatus != "done"]', style: { 'line-color': '#f59e0b', 'target-arrow-color': '#f59e0b' } },
            { selector: 'edge[targetPriority = "critical"][targetStatus != "done"]', style: { 'line-color': '#ef4444', 'target-arrow-color': '#ef4444' } },
            /* Cytoscape doesn't support :hover selector here; remove to avoid errors */
            /* { selector: 'edge:hover', style: { 'line-color': '#334155', 'target-arrow-color': '#334155', 'width': 2.5, 'arrow-scale': 1.5 } }, */
            { selector: 'edge:selected', style: { 'line-color': '#0ea5e9', 'target-arrow-color': '#0ea5e9', 'width': 2.5, 'arrow-scale': 1.5 } },
            { selector: 'node[status = "planned"]', style: { 'background-color': '#38bdf8' } },
            { selector: 'node[status = "done"]', style: { 'background-color': '#22c55e' } },
            { selector: 'node[status = "in-progress"]', style: { 'background-color': '#f59e0b' } },
            { selector: 'node[status = "blocked"]', style: { 'background-color': '#ef4444' } },
            { selector: '.cp', style: { 'border-width': 4, 'border-color': '#14b8a6' } },
            { selector: 'node[?is_group]', style: {
                'shape': 'ellipse',
                'width': 'mapData(score, 0, 10, 28, 68)',
                'height': 'mapData(score, 0, 10, 28, 68)',
                'border-width': 0,
                'border-color': '#0f172a',
                'border-opacity': 0,
                'background-opacity': 0,
                'background-color': 'transparent'
              }
            },
            { selector: 'node.collapsed', style: {
                'background-image': 'data(dotIcon)',
                'background-fit': 'contain',
                'background-width': '65%',
                'background-height': '65%',
                'background-position-x': '50%',
                'background-position-y': '50%',
                'background-repeat': 'no-repeat'
              }
            },
          ],
          layout: { name: allHavePositions ? 'preset' : 'preset' }
        });
        cy.fit();

        // Recompute priority-based path coloring on current graph
        function recomputePriorityPaths(){
          const rank = (p) => (p==='critical'?2:(p==='high'?1:0));
          // node state: highest priority reachable downstream from this node (including its own if not done)
          const nodeState = new Map();
          cy.nodes().forEach(n=>nodeState.set(n.id(), 0));
          // seed nodes: those with priority high/critical and not done
          const seeds = [];
          cy.nodes().forEach(n=>{
            const status = String(n.data('status')||'planned');
            if (status !== 'done'){
              const pr = String(n.data('priority')||'normal');
              const r = rank(pr);
              if (r>0){ nodeState.set(n.id(), r); seeds.push(n.id()); }
            }
          });
          cy.edges().forEach(e=>e.data('pathPriority','none'));
          // reverse BFS propagation
          const queue = [...seeds];
          while(queue.length){
            const tgtId = queue.shift();
            const tgtRank = nodeState.get(tgtId)||0;
            cy.edges(`[target = "${tgtId}"]`).forEach(e=>{
              // set edge path priority
              if (tgtRank===2) e.data('pathPriority','critical');
              else if (tgtRank===1) e.data('pathPriority','high');
              // propagate to source node
              const srcId = String(e.data('source'));
              const cur = nodeState.get(srcId)||0;
              if (tgtRank>cur){ nodeState.set(srcId, tgtRank); queue.push(srcId); }
            });
          }
        }
        // initial compute
        recomputePriorityPaths();

        function applyInitialPositions() {
          // Set saved positions for nodes that have them
          cy.nodes().forEach(n => {
            const x = n.data('savedX');
            const y = n.data('savedY');
            if (typeof x === 'number' && typeof y === 'number') {
              n.position({ x, y });
            }
          });
          // Layout only nodes without saved positions
          const needLayout = cy.nodes().filter(n => !(typeof n.data('savedX') === 'number' && typeof n.data('savedY') === 'number'));
          if (needLayout.length > 0) {
            needLayout.layout({ name: 'cose' }).run();
          }
        }
        applyInitialPositions();

        const selEl = document.getElementById('selNode');
        let selectedNodeId = null;
        let selectedEdgeId = null;
        async function refreshLists(nodeId) {
          const lang = (document.getElementById('langSelect')?.value || '');
          const q = lang ? `?lang=${encodeURIComponent(lang)}` : '';
          const [c, t, k] = await Promise.all([
            fetch(`/api/v1/nodes/${nodeId}/comments${q}`).then(r=>r.json()),
            fetch(`/api/v1/nodes/${nodeId}/time-entries`).then(r=>r.json()),
            fetch(`/api/v1/nodes/${nodeId}/cost-entries`).then(r=>r.json()),
          ]);
          const commentsList = document.getElementById('commentsList');
          commentsList.innerHTML = '';
          c.data.forEach(x => {
            const li = document.createElement('li');
            const body = document.createElement('span'); body.textContent = (x.body_translated || x.body);
            const time = document.createElement('span'); time.className = 'ml-2 text-xs text-slate-500'; time.textContent = formatDate(x.created_at);
            li.appendChild(body); li.appendChild(time);
            commentsList.appendChild(li);
          });
          const timeList = document.getElementById('timeList');
          timeList.innerHTML = '';
          t.data.forEach(x => {
            const li = document.createElement('li');
            li.textContent = `${x.hours}h`;
            timeList.appendChild(li);
          });
          const costList = document.getElementById('costList');
          costList.innerHTML = '';
          k.data.forEach(x => {
            const li = document.createElement('li');
            const amt = document.createElement('span'); amt.textContent = `${x.amount} ${x.currency || 'USD'}`;
            const when = document.createElement('span'); when.className = 'ml-2 text-xs text-slate-500'; when.textContent = formatDate(x.incurred_at);
            li.appendChild(amt); li.appendChild(when);
            costList.appendChild(li);
          });
          // status history
          try {
            const h = await fetch(`/api/v1/nodes/${nodeId}/status-history`).then(r=>r.json());
            const sh = document.getElementById('statusHistory');
            sh.innerHTML = '';
            (h.data || []).forEach(x => {
              const li = document.createElement('li');
              li.textContent = `${x.old_status} → ${x.new_status}`;
              const when = document.createElement('span'); when.className = 'ml-2 text-xs text-slate-500'; when.textContent = formatDate(x.created_at);
              li.appendChild(when);
              sh.appendChild(li);
            });
          } catch {}
        }

        cy.on('tap', 'node', async (evt) => {
          selectedNodeId = evt.target.data('id');
          selEl.textContent = selectedNodeId;
          const titleEl = document.getElementById('selNodeTitle');
          if (titleEl) titleEl.textContent = String(evt.target.data('label') || '—');
          try {
            const lang = (document.getElementById('langSelect')?.value || '');
            const out = document.getElementById('selNodeTitleTranslated');
            if (!lang) { if(out) out.value=''; }
            else {
              const r = await fetch(`/api/v1/nodes/${selectedNodeId}/translation?lang=${encodeURIComponent(lang)}`).then(x=>x.json());
              const t = r && r.data && r.data.text;
              if (out) out.value = t || '';
            }
          } catch {}
          const createdEl = document.getElementById('createdAt');
          if (createdEl) createdEl.textContent = formatDate(evt.target.data('created_at'));
          const delBtn = document.getElementById('btnDeleteNodePanel');
          if (delBtn) delBtn.classList.remove('hidden');
          const prSel = document.getElementById('prioritySelect');
          if (prSel) prSel.value = String(evt.target.data('priority') || 'normal');
          // compute descendants via outgoing edges (reachability)
          const start = cy.getElementById(selectedNodeId);
          let count = 0;
          if (start && start.nonempty()) {
            const visited = new Set([start.id()]);
            const queue = [start];
            while (queue.length) {
              const cur = queue.shift();
              const out = cur.outgoers('edge');
              out.targets().forEach(t => {
                if (!visited.has(t.id())) { visited.add(t.id()); queue.push(t); count++; }
              });
            }
          }
          const dc = document.getElementById('descCount');
          if (dc) dc.textContent = String(count);
          selectedEdgeId = null;
          // set status select to node status
          const sel = document.getElementById('statusSelect');
          if (sel) sel.value = String(evt.target.data('status') || 'planned');
          await refreshLists(selectedNodeId);
        });
        cy.on('tap', 'edge', (evt) => {
          selectedEdgeId = evt.target.data('id');
          selectedNodeId = null;
          selEl.textContent = '—';
          const delBtn = document.getElementById('btnDeleteNodePanel');
          if (delBtn) delBtn.classList.add('hidden');
        });

        async function postJSON(url, data) {
          const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) });
          if (res.status === 401) { alert('Login required'); throw new Error('Unauthorized'); }
          if (!res.ok) throw new Error('Request failed');
          return res.json();
        }
        async function patchJSON(url, data) {
          const res = await fetch(url, { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) });
          if (res.status === 401) { alert('Login required'); throw new Error('Unauthorized'); }
          if (!res.ok) throw new Error('Request failed');
          return res.json();
        }
        async function del(url) {
          const res = await fetch(url, { method: 'DELETE' });
          if (res.status === 401) { alert('Login required'); throw new Error('Unauthorized'); }
          if (!res.ok && res.status !== 204) throw new Error('Request failed');
        }

        function addNodeToCy(n) {
          const ext = cy.extent();
          const padding = 30;
          const pos = { x: ext.x1 + padding, y: ext.y1 + padding };
          cy.add({ group: 'nodes', data: { id: n.id, label: n.title, score: n.importance_score || 0, status: n.status || 'todo', savedX: pos.x, savedY: pos.y }, position: pos });
          // Persist initial position best-effort
          postJSON(`/api/v1/nodes/${n.id}/position`, { x: pos.x, y: pos.y }).catch(()=>{});
        }
        function addEdgeToCy(e) {
          const tgt = cy.getElementById(String(e.target_node_id));
          const tp = tgt && tgt.nonempty() ? (tgt.data('priority') || 'normal') : 'normal';
          cy.add({ group: 'edges', data: { id: e.id, source: e.source_node_id, target: e.target_node_id, type: e.type, weight: e.weight, targetPriority: tp } });
          // recompute descendants sizes quickly
          const nodes = cy.nodes();
          const adj = new Map();
          nodes.forEach(n => adj.set(n.id(), []));
          cy.edges().forEach(ed => { const a = adj.get(ed.data('source')); if (a) a.push(ed.data('target')); });
          function countDesc(start){ const vis = new Set([start]); const q=[start]; let c=0; while(q.length){ const cur=q.shift(); (adj.get(cur)||[]).forEach(t=>{ if(!vis.has(t)){vis.add(t); q.push(t); c++; } }); } return c; }
          nodes.forEach(n => n.data('descendants', countDesc(n.id())));
          recomputePriorityPaths();
        }

        document.getElementById('commentForm').addEventListener('submit', async (e) => {
          e.preventDefault();
          if (!selectedNodeId) return;
          const fd = new FormData(e.target);
          await postJSON(`/api/v1/nodes/${selectedNodeId}/comments`, { body: fd.get('body') });
          e.target.reset();
          await refreshLists(selectedNodeId);
        });

        document.getElementById('timeForm').addEventListener('submit', async (e) => {
          e.preventDefault();
          if (!selectedNodeId) return;
          const fd = new FormData(e.target);
          await postJSON(`/api/v1/nodes/${selectedNodeId}/time-entries`, { user_id: fd.get('user_id'), hours: parseFloat(fd.get('hours')) || 0 });
          e.target.reset();
          await refreshLists(selectedNodeId);
        });

        // Status selector change handler
        document.getElementById('statusSelect').addEventListener('change', async (e) => {
          if (!selectedNodeId) return;
          const value = e.target.value;
          const resp = await patchJSON(`/api/v1/nodes/${selectedNodeId}`, { status: value });
          const n = cy.getElementById(selectedNodeId);
          n.data('status', resp.data.status);
          recomputePriorityPaths();
          // Refresh status history after change
          try { await refreshLists(selectedNodeId); } catch {}
        });

        // Priority change handler
        document.getElementById('prioritySelect').addEventListener('change', async (e) => {
          if (!selectedNodeId) return;
          const value = e.target.value;
          const resp = await patchJSON(`/api/v1/nodes/${selectedNodeId}`, { priority: value });
          const n = cy.getElementById(selectedNodeId);
          n.data('priority', resp.data.priority || value);
          recomputePriorityPaths();
        });

        document.getElementById('costForm').addEventListener('submit', async (e) => {
          e.preventDefault();
          if (!selectedNodeId) return;
          const fd = new FormData(e.target);
          await postJSON(`/api/v1/nodes/${selectedNodeId}/cost-entries`, { amount: parseFloat(fd.get('amount')) || 0, currency: 'USD', incurred_at: new Date().toISOString() });
          e.target.reset();
          await refreshLists(selectedNodeId);
        });

        document.getElementById('btnAddNode').addEventListener('click', async () => {
          const title = prompt('Node title');
          if (!title) return;
          const resp = await postJSON(`/api/v1/projects/${projectId}/nodes`, { title });
          addNodeToCy(resp.data);
        });

        // Removed old Edit Node toolbar flow (replaced by inline editor)

        // Inline edit selected node title (Task Panel)
        const titleInlineEl = document.getElementById('selNodeTitle');
        function commitInlineTitle(){
          if (!selectedNodeId) return;
          const newTitle = (titleInlineEl.textContent || '').trim();
          if (!newTitle) { return; }
          patchJSON(`/api/v1/nodes/${selectedNodeId}`, { title: newTitle })
            .then(resp => {
              const n = cy.getElementById(selectedNodeId);
              if (n) n.data('label', resp.data.title);
            })
            .catch(()=>{});
        }
        titleInlineEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') { e.preventDefault(); commitInlineTitle(); titleInlineEl.blur(); }
        });
        titleInlineEl.addEventListener('blur', () => commitInlineTitle());

        document.getElementById('btnDeleteNodePanel').addEventListener('click', async () => {
          if (!selectedNodeId) { alert('Select a node'); return; }
          if (!confirm('Delete node?')) return;
          await del(`/api/v1/nodes/${selectedNodeId}`);
          cy.getElementById(selectedNodeId).remove();
          selectedNodeId = null;
          selEl.textContent = '—';
        });

        // Unified connect mode: via button or hold 'c'. ESC / click background cancels. Prevent dup/invalid.
        (function connectMode(){
          let active = false; let sourceId = null; let timeoutId = null;
          const srcClass = 'connect-source';
          // hint overlay
          const hint = document.createElement('div');
          hint.className = 'pointer-events-none fixed inset-x-0 top-16 text-center z-40';
          hint.style.display = 'none';
          hint.innerHTML = '<span class="inline-block px-3 py-1 bg-black/70 text-white rounded">Connect mode: click source, then target (ESC to cancel, hold C/С for quick connect)</span>';
          document.body.appendChild(hint);
          function setActive(on){
            active = on; if (!on) { sourceId = null; cy.nodes().removeClass(srcClass); if (timeoutId) { clearTimeout(timeoutId); timeoutId=null; } cy.container().style.cursor=''; hint.style.display='none'; }
            else { cy.container().style.cursor='crosshair'; hint.style.display=''; timeoutId = setTimeout(()=>setActive(false), 10000); }
          }
          function cancel(){ setActive(false); }
          function tryCreateEdge(targetId){
            if (!sourceId || sourceId === targetId) return;
            const srcEl = cy.getElementById(sourceId); const tgtEl = cy.getElementById(targetId);
            if (!srcEl.nonempty() || !tgtEl.nonempty()) { cancel(); return; }
            // prevent duplicates
            const dup = cy.edges().some(e => e.data('source')===sourceId && e.data('target')===targetId);
            if (dup) { cancel(); return; }
            postJSON(`/api/v1/projects/${projectId}/edges`, { source_node_id: sourceId, target_node_id: targetId })
              .then(resp => addEdgeToCy(resp.data))
              .finally(() => cancel());
          }
          const pickHandler = (evt) => {
            if (!active) return;
            const id = evt.target.data('id');
            if (!sourceId) { sourceId = id; cy.getElementById(sourceId).addClass(srcClass); }
            else { tryCreateEdge(id); }
          };
          cy.on('tap', 'node', pickHandler);
          cy.on('tap', (evt) => { if (active && evt.target === cy) cancel(); });
          const isConnectKey = (k) => { const v=(k||'').toLowerCase(); return v==='c' || v==='с'; };
          document.addEventListener('keydown', (e)=>{ if (isConnectKey(e.key) && !active){ setActive(true); }});
          document.addEventListener('keyup', (e)=>{ if (isConnectKey(e.key)){ cancel(); }});
          document.getElementById('btnAddEdge').addEventListener('click', ()=>{ setActive(true); });
          document.addEventListener('keydown', (e)=>{ if (e.key==='Escape' && active){ e.preventDefault(); cancel(); }});
        })();

        // Edge delete helper (invoked by keyboard shortcut)
        async function deleteSelectedEdge(){
          if (!selectedEdgeId) { alert('Tap an edge to select it'); return; }
          if (!confirm('Delete edge?')) return;
          await del(`/api/v1/edges/${selectedEdgeId}`);
          cy.getElementById(selectedEdgeId).remove();
          selectedEdgeId = null;
        }

        document.getElementById('btnCriticalPath').addEventListener('click', async () => {
          const res = await fetch(`/api/v1/projects/${projectId}/metrics`).then(r=>r.json());
          const ids = (res.data && res.data.critical_path_hint && res.data.critical_path_hint.node_ids) || [];
          cy.elements().removeClass('cp');
          ids.forEach((id, i) => {
            const el = cy.getElementById(id);
            el.addClass('cp');
          });
        });

        // Multi-select (hold Shift to select multiple)
        let multiSelected = new Set();
        cy.on('tap', 'node', (evt) => {
          if (evt.originalEvent && evt.originalEvent.shiftKey) {
            const id = evt.target.id();
            if (multiSelected.has(id)) multiSelected.delete(id); else multiSelected.add(id);
            evt.target.toggleClass('cp');
          } else {
            multiSelected.clear();
          }
        });

        document.getElementById('btnGroup').addEventListener('click', async () => {
          if (multiSelected.size < 1) { alert('Hold Shift and select nodes to group'); return; }
          const title = prompt('Group title', 'Group') || 'Group';
          const ids = Array.from(multiSelected);
          const res = await postJSON(`/api/v1/projects/${projectId}/groups`, { title, node_ids: ids });
          // reload graph for simplicity
          graph = await fetchGraph();
          cy.elements().remove();
          cy.add(toElements(graph));
          cy.layout({ name: 'preset' }).run();
          cy.fit();
          multiSelected.clear();
        });

        document.getElementById('btnUngroup').addEventListener('click', async () => {
          if (!selectedNodeId) { alert('Select a group node'); return; }
          const nd = cy.getElementById(selectedNodeId);
          if (!nd || !nd.data('is_group')) { alert('Selected node is not a group'); return; }
          await postJSON(`/api/v1/groups/${selectedNodeId}/ungroup`, {});
          graph = await fetchGraph();
          cy.elements().remove();
          cy.add(toElements(graph));
          cy.layout({ name: 'preset' }).run();
        });

        // Collapse / Expand groups (pure UI)
        const collapsedGroups = new Set((JSON.parse(localStorage.getItem('collapsedGroups') || '[]') || []).map(String));
        function persistCollapsed() {
          localStorage.setItem('collapsedGroups', JSON.stringify(Array.from(collapsedGroups)));
        }
        function collapseGroup(groupId) {
          const gid = String(groupId);
          const children = cy.nodes().filter(n => String(n.data('parent')) === gid);
          children.forEach(ch => { ch.data('origParent', gid); ch.move({ parent: null }); ch.style('display', 'none'); });
          const grp = cy.getElementById(groupId);
          if (grp) grp.addClass('collapsed');
        }
        function expandGroup(groupId) {
          const gid = String(groupId);
          const children = cy.nodes().filter(n => String(n.data('origParent')) === gid);
          children.forEach(ch => { ch.move({ parent: gid }); ch.removeData('origParent'); ch.style('display', 'element'); });
          const grp = cy.getElementById(groupId);
          if (grp) grp.removeClass('collapsed');
        }
        // Apply persisted states after initial render
        // 1) Collapse ALL groups by default
        cy.nodes('[?is_group]').forEach(g => collapseGroup(g.id()));
        // 2) Expand those that are not in persisted collapsed set
        cy.nodes('[?is_group]').forEach(g => {
          if (!collapsedGroups.has(String(g.id()))) {
            expandGroup(g.id());
          }
        });

        // 3) Re-apply saved positions for groups to override any layout shifts
        function reapplySavedGroupPositions() {
          cy.nodes('[?is_group]').forEach(g => {
            const x = g.data('savedX');
            const y = g.data('savedY');
            if (typeof x === 'number' && typeof y === 'number') {
              g.position({ x, y });
            }
          });
        }
        reapplySavedGroupPositions();

        document.getElementById('btnCollapse').addEventListener('click', () => {
          if (!selectedNodeId) { alert('Select a group node'); return; }
          const nd = cy.getElementById(selectedNodeId);
          if (!nd || !nd.data('is_group')) { alert('Selected node is not a group'); return; }
          collapseGroup(selectedNodeId);
          collapsedGroups.add(selectedNodeId);
          persistCollapsed();
        });

        document.getElementById('btnExpand').addEventListener('click', () => {
          if (!selectedNodeId) { alert('Select a group node'); return; }
          const nd = cy.getElementById(selectedNodeId);
          if (!nd || !nd.data('is_group')) { alert('Selected node is not a group'); return; }
          expandGroup(selectedNodeId);
          collapsedGroups.delete(selectedNodeId);
          persistCollapsed();
        });

        // Double-click (fast two taps) on group to toggle collapse/expand
        let lastTapAt = 0;
        let lastTapId = null;
        cy.on('tap', 'node', (evt) => {
          // ignore when using Shift multi-select
          if (evt.originalEvent && evt.originalEvent.shiftKey) return;
          const id = evt.target.id();
          const now = Date.now();
          if (evt.target.data('is_group') && lastTapId === id && (now - lastTapAt) < 300) {
            const isCollapsed = collapsedGroups.has(id);
            if (isCollapsed) { expandGroup(id); collapsedGroups.delete(id); }
            else { collapseGroup(id); collapsedGroups.add(id); }
            persistCollapsed();
            lastTapAt = 0; lastTapId = null;
          } else {
            lastTapAt = now; lastTapId = id;
          }
        });

        // LOD: hide nodes below threshold depending on zoom level
        function applyLOD() {
          const z = cy.zoom();
          const total = cy.nodes().length;
          // Only hide at low zoom for sufficiently large graphs
          let threshold = -1;
          if (total > 100) {
            if (z < 0.4) threshold = 1.5;
            else if (z < 0.8) threshold = 0.6;
            else threshold = -1;
          }

          let shown = 0;
          cy.nodes().forEach(n => {
            const score = n.data('score') || 0;
            const isSelected = selectedNodeId && n.id() === selectedNodeId;
            const isCollapsedChild = Boolean(n.data('origParent'));
            const visible = !isCollapsedChild && (threshold < 0 || score >= threshold || isSelected);
            n.style('display', visible ? 'element' : 'none');
            if (visible) shown++;
          });

          // Safety: if nothing would be visible, show all
          if (shown === 0) {
            cy.nodes().forEach(n => {
              if (!n.data('origParent')) n.style('display', 'element');
            });
          }
        }
        cy.on('zoom', applyLOD);
        applyLOD();

        // Reset helpers
        function visibleCount(){
          let shown = 0; cy.nodes().forEach(n=>{ if (n.style('display') !== 'none' && !n.data('origParent')) shown++; }); return shown;
        }
        function resetCollapsed(){
          collapsedGroups.clear(); persistCollapsed();
          cy.nodes('[?is_group]').forEach(g=>{ expandGroup(g.id()); });
        }
        function resetFilters(){
          const s=document.getElementById('statusFilter'); if (s) s.value='';
          const q=document.getElementById('searchBox'); if (q) q.value='';
          applySearchAndFilter();
        }
        function showAllAndFit(){
          resetCollapsed(); resetFilters();
          cy.nodes().forEach(n=>{ if (!n.data('origParent')) n.style('display','element'); });
          cy.zoom(1); cy.fit();
          console.log('[AutoFix] showAllAndFit applied. nodes:', cy.nodes().length, 'visible:', visibleCount());
        }
        document.getElementById('btnResetView').addEventListener('click', showAllAndFit);

        // Auto self-heal: if after initial render ничего не видно — сбросить вид
        setTimeout(() => {
          try {
            const vis = visibleCount();
            if (cy.nodes().length > 0 && vis === 0) { showAllAndFit(); }
          } catch {}
        }, 300);

        // Search/filter
        function applySearchAndFilter() {
          const q = (document.getElementById('searchBox').value || '').toLowerCase();
          const f = (document.getElementById('statusFilter').value || '').toLowerCase();
          cy.nodes().forEach(n => {
            const matchesText = !q || (String(n.data('label') || '').toLowerCase().includes(q));
            // Internal status uses 'planned' for what UI calls 'Todo'
            const statusValue = String(n.data('status') || '').toLowerCase();
            const filterValue = f === 'planned' ? 'planned' : f;
            const matchesStatus = !f || (statusValue === filterValue);
            n.style('opacity', (matchesText && matchesStatus) ? 1 : 0.15);
          });
        }
        document.getElementById('searchBox').addEventListener('input', applySearchAndFilter);
        document.getElementById('statusFilter').addEventListener('change', applySearchAndFilter);

        // Fit
        document.getElementById('btnFit').addEventListener('click', () => cy.fit());

        // Language toggle
        const langSel = document.getElementById('langSelect');
        langSel.value = savedLang;
        async function ensureTranslations(lang){
          if (!lang) return;
          try { await fetch(`/api/v1/projects/${projectId}/translate`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ lang, include_nodes: true, stale: false }) }); } catch {}
        }
        langSel.addEventListener('change', async (e)=>{
          const lang = e.target.value;
          localStorage.setItem('displayLang', lang);
          if (lang) await ensureTranslations(lang);
          graph = await fetchGraph(lang);
          cy.elements().remove();
          cy.add(toElements(graph));
          cy.layout({ name: 'preset' }).run();
          cy.fit();
        });

        document.getElementById('btnTrStats').addEventListener('click', async ()=>{
          const lang = (document.getElementById('langSelect')?.value || 'en');
          try {
            const s = await fetch(`/api/v1/projects/${projectId}/translation/stats?lang=${encodeURIComponent(lang)}`).then(r=>r.json());
            const d = s.data || {};
            alert(`Translation stats (${lang}):\nMissing nodes: ${d.missing_nodes}\nStale nodes: ${d.stale_nodes}\nMissing comments: ${d.missing_comments}\nStale comments: ${d.stale_comments}`);
          } catch { alert('Failed to fetch stats'); }
        });

        document.getElementById('btnTrRun').addEventListener('click', async ()=>{
          const lang = (document.getElementById('langSelect')?.value || 'en');
          const btn = document.getElementById('btnTrRun');
          const oldText = btn.textContent;
          let preflightTotalAll = 0;
          // Ask user for mode: OK => force overwrite all; Cancel => only missing/stale
          const forceMode = window.confirm('Force mode?\nOK = overwrite ALL existing translations (force=true)\nCancel = only missing/stale (force=false)');
          try {
            btn.disabled = true; btn.textContent = 'Translating…';
            // Preflight: if nothing to translate, stop early and re-enable
            try {
              const s = await fetch(`/api/v1/projects/${projectId}/translation/stats?lang=${encodeURIComponent(lang)}`).then(r=>r.json());
              const d = s?.data || {};
              const totalAll = (d.total_nodes||0) + (d.total_comments||0);
              preflightTotalAll = totalAll;
              btn.textContent = `Translating… 0/${totalAll}`;
              const totalLeft = (d.missing_nodes||0)+(d.stale_nodes||0)+(d.missing_comments||0)+(d.stale_comments||0);
              if (!totalLeft) {
                btn.disabled = false; btn.textContent = oldText;
                alert('Nothing to translate');
                return;
              }
            } catch {}
            // Sync translate (temporary fallback while async queue is under maintenance)
            const syncResp = await fetch(`/api/v1/projects/${projectId}/translate`, {
              method: 'POST', headers: {'Content-Type': 'application/json'},
              body: JSON.stringify({ lang, include_nodes: true, include_comments: true, stale: true, provider: 'gemini', force: !!forceMode })
            });
            if (!syncResp.ok) {
              let detail = '';
              try {
                const t = await syncResp.text();
                detail = (t || '').slice(0, 2000);
              } catch {}
              // Show copyable error panel
              (async function(){
                let panel = document.getElementById('copyableErrorPanel');
                if (!panel){
                  panel = document.createElement('div');
                  panel.id = 'copyableErrorPanel';
                  panel.style.position = 'fixed';
                  panel.style.left = '50%';
                  panel.style.top = '50%';
                  panel.style.transform = 'translate(-50%, -50%)';
                  panel.style.zIndex = '9999';
                  panel.style.width = '520px';
                  panel.style.maxWidth = '92vw';
                  panel.style.background = '#111827';
                  panel.style.color = '#e5e7eb';
                  panel.style.border = '1px solid #374151';
                  panel.style.borderRadius = '8px';
                  panel.style.boxShadow = '0 10px 20px rgba(0,0,0,0.3)';
                  panel.style.padding = '12px';
                  panel.style.maxHeight = '80vh';
                  panel.style.overflow = 'auto';

                  const title = document.createElement('div');
                  title.textContent = 'Error details';
                  title.style.fontWeight = '600';
                  title.style.marginBottom = '8px';
                  panel.appendChild(title);

                  const ta = document.createElement('textarea');
                  ta.id = 'copyableErrorText';
                  ta.readOnly = true;
                  ta.style.width = '100%';
                  ta.style.height = '160px';
                  ta.style.background = '#0b1220';
                  ta.style.color = '#e5e7eb';
                  ta.style.border = '1px solid #374151';
                  ta.style.borderRadius = '6px';
                  ta.style.padding = '8px';
                  ta.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
                  panel.appendChild(ta);

                  const row = document.createElement('div');
                  row.style.display = 'flex';
                  row.style.gap = '8px';
                  row.style.marginTop = '8px';

                  const btnCopy = document.createElement('button');
                  btnCopy.textContent = 'Copy';
                  btnCopy.className = 'px-3 py-1 bg-slate-200 text-slate-800 rounded';
                  btnCopy.addEventListener('click', ()=>{ ta.select(); try { document.execCommand('copy'); } catch {} });
                  row.appendChild(btnCopy);

                  const btnClose = document.createElement('button');
                  btnClose.textContent = 'Close';
                  btnClose.className = 'px-3 py-1 bg-slate-200 text-slate-800 rounded';
                  btnClose.addEventListener('click', ()=>{ panel.style.display = 'none'; });
                  row.appendChild(btnClose);

                  panel.appendChild(row);
                  document.body.appendChild(panel);
                }
                // fetch pid
                let pid = '';
                try { const h = await fetch('/api/v1/health').then(r=>r.json()); pid = (h && h.data && h.data.pid) ? String(h.data.pid) : ''; } catch {}
                const taEl = document.getElementById('copyableErrorText');
                if (taEl){ taEl.value = `sync failed (${syncResp.status}) pid=${pid}\n${detail}`; taEl.select(); }
                panel.style.display = '';
              })();
              btn.disabled = false; btn.textContent = oldText;
              return;
            }
            const sync = await syncResp.json();
            const translated = (sync && sync.data && sync.data.translated) || 0;
            btn.disabled = false; btn.textContent = oldText;
            alert(`Done. Translated: ${translated}`);
            const currentLang = (document.getElementById('langSelect')?.value || '');
            graph = await fetchGraph(currentLang);
            cy.elements().remove();
            cy.add(toElements(graph));
            cy.layout({ name: 'preset' }).run();
            cy.fit();
          } catch (e) {
            btn.disabled = false; btn.textContent = oldText;
            const msg = (e && e.message) ? e.message : 'Translation failed';
            (async function(){
              let panel = document.getElementById('copyableErrorPanel');
              if (!panel){
                panel = document.createElement('div');
                panel.id = 'copyableErrorPanel';
                panel.style.position = 'fixed';
                panel.style.left = '50%';
                panel.style.top = '50%';
                panel.style.transform = 'translate(-50%, -50%)';
                panel.style.zIndex = '9999';
                panel.style.width = '520px';
                panel.style.maxWidth = '92vw';
                panel.style.background = '#111827';
                panel.style.color = '#e5e7eb';
                panel.style.border = '1px solid #374151';
                panel.style.borderRadius = '8px';
                panel.style.boxShadow = '0 10px 20px rgba(0,0,0,0.3)';
                panel.style.padding = '12px';
                panel.style.maxHeight = '80vh';
                panel.style.overflow = 'auto';
                const title = document.createElement('div');
                title.textContent = 'Error details';
                title.style.fontWeight = '600';
                title.style.marginBottom = '8px';
                panel.appendChild(title);
                const ta = document.createElement('textarea');
                ta.id = 'copyableErrorText';
                ta.readOnly = true;
                ta.style.width = '100%';
                ta.style.height = '160px';
                ta.style.background = '#0b1220';
                ta.style.color = '#e5e7eb';
                ta.style.border = '1px solid #374151';
                ta.style.borderRadius = '6px';
                ta.style.padding = '8px';
                ta.style.fontFamily = 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace';
                panel.appendChild(ta);
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.gap = '8px';
                row.style.marginTop = '8px';
                const btnCopy = document.createElement('button');
                btnCopy.textContent = 'Copy';
                btnCopy.className = 'px-3 py-1 bg-slate-200 text-slate-800 rounded';
                btnCopy.addEventListener('click', ()=>{ ta.select(); try { document.execCommand('copy'); } catch {} });
                row.appendChild(btnCopy);
                const btnClose = document.createElement('button');
                btnClose.textContent = 'Close';
                btnClose.className = 'px-3 py-1 bg-slate-200 text-slate-800 rounded';
                btnClose.addEventListener('click', ()=>{ panel.style.display = 'none'; });
                row.appendChild(btnClose);
                panel.appendChild(row);
                document.body.appendChild(panel);
              }
              let pid = '';
              try { const h = await fetch('/api/v1/health').then(r=>r.json()); pid = (h && h.data && h.data.pid) ? String(h.data.pid) : ''; } catch {}
              const taEl = document.getElementById('copyableErrorText');
              if (taEl){ taEl.value = (pid ? `pid=${pid}\n` : '') + String(msg||''); taEl.select(); }
              panel.style.display = '';
            })();
          } finally {
            // Safety unlock after 15s in any case
            setTimeout(()=>{ if(btn.disabled){ btn.disabled=false; btn.textContent=oldText; } }, 15000);
          }
        });

        document.getElementById('btnRefreshTranslation').addEventListener('click', async ()=>{
          if (!selectedNodeId) { alert('Select a node'); return; }
          const lang = (document.getElementById('langSelect')?.value || 'en');
          try {
            const res = await fetch(`/api/v1/nodes/${selectedNodeId}/translate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ lang, provider: 'mymemory' }) }).then(r=>r.json());
            const out = document.getElementById('selNodeTitleTranslated');
            if (out) out.value = (res && res.data && res.data.text) || '';
            // also refresh label for this node in graph if language currently selected
            const currentLang = (document.getElementById('langSelect')?.value || '');
            if (currentLang) {
              const n = cy.getElementById(String(selectedNodeId));
              if (n && n.nonempty()) n.data('label', out.value || n.data('label'));
            }
          } catch { alert('Failed to refresh translation'); }
        });

        // Zoom controls with smooth animation
        function smoothZoom(factor){
          const target = cy.zoom() * factor;
          cy.animate({ zoom: target }, { duration: 200, easing: 'ease-in-out' });
        }
        document.getElementById('zoomIn').addEventListener('click', () => smoothZoom(1.2));
        document.getElementById('zoomOut').addEventListener('click', () => smoothZoom(1/1.2));
        // smoother wheel zoom (RAF-based, responsive, anchored to cursor)
        cy.userZoomingEnabled(false);
        const cyContainer = cy.container();
        let targetZoom = cy.zoom();
        let anchor = { x: 0, y: 0 };
        let zooming = false;
        function stepZoom(){
          if (!zooming) return;
          const current = cy.zoom();
          const next = current + (targetZoom - current) * 0.25; // responsiveness factor
          cy.zoom({ level: next, renderedPosition: anchor });
          if (Math.abs(targetZoom - next) < 0.001) { zooming = false; return; }
          requestAnimationFrame(stepZoom);
        }
        cyContainer.addEventListener('wheel', (e) => {
          e.preventDefault();
          const rect = cyContainer.getBoundingClientRect();
          anchor = { x: e.clientX - rect.left, y: e.clientY - rect.top };
          const factor = Math.exp(-e.deltaY * 0.0012); // slightly faster response
          targetZoom = Math.max(0.05, Math.min(10, targetZoom * factor));
          if (!zooming) { zooming = true; requestAnimationFrame(stepZoom); }
        }, { passive: false });

        // Toggle sidebar
        const sidebar = document.getElementById('sidebar');
        const toggleBtn = document.getElementById('btnToggleSidebar');
        function applySidebarVisibility(){
          const hidden = localStorage.getItem('sidebarHidden') === '1';
          if (hidden) {
            sidebar.style.display = 'none';
          } else {
            sidebar.style.display = '';
          }
          setTimeout(() => cy.resize(), 0);
        }
        toggleBtn.addEventListener('click', () => {
          const hidden = localStorage.getItem('sidebarHidden') === '1';
          localStorage.setItem('sidebarHidden', hidden ? '0' : '1');
          applySidebarVisibility();
        });
        applySidebarVisibility();

        // Sidebar resizer
        (function setupResizer(){
          const resizer = document.getElementById('resizer');
          const sidebar = document.getElementById('sidebar');
          function loadWidth(){
            const w = parseInt(localStorage.getItem('sidebarWidth') || '384', 10);
            const clamped = Math.max(260, Math.min(560, w));
            sidebar.style.width = clamped + 'px';
          }
          loadWidth();
          let dragging = false;
          let startX = 0;
          let startW = 384;
          resizer.addEventListener('mousedown', (e) => {
            dragging = true; startX = e.clientX; startW = sidebar.offsetWidth;
            document.body.classList.add('select-none'); document.body.style.cursor = 'col-resize';
            e.preventDefault();
          });
          window.addEventListener('mouseup', () => {
            if (!dragging) return;
            dragging = false;
            document.body.classList.remove('select-none');
            document.body.style.cursor = '';
            localStorage.setItem('sidebarWidth', parseInt(sidebar.style.width||'384',10));
          });
          window.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            // Dragging left should INCREASE width, right should decrease
            const delta = startX - e.clientX; // left: positive, right: negative
            const newW = Math.max(260, Math.min(560, startW + delta));
            sidebar.style.width = newW + 'px';
            cy.resize();
          });
          // Hide resizer if sidebar hidden
          function syncResizer(){ resizer.style.display = (localStorage.getItem('sidebarHidden') === '1') ? 'none' : ''; }
          syncResizer();
          toggleBtn.addEventListener('click', () => { setTimeout(() => { syncResizer(); cy.resize(); }, 0); });
        })();

        // Panel tabs: Task | Settings
        const tabTask = document.getElementById('tabTask');
        const tabSettings = document.getElementById('tabSettings');
        const taskPanel = document.getElementById('taskPanel');
        const settingsPanel = document.getElementById('settingsPanel');
        // ensure declared before any call path
        let settingsLoaded = false;
        function showTask(){
          taskPanel.classList.remove('hidden');
          settingsPanel.classList.add('hidden');
          tabTask.className = 'px-2 py-1 text-xs rounded bg-slate-800 text-white';
          tabSettings.className = 'px-2 py-1 text-xs rounded bg-slate-200 text-slate-800';
          localStorage.setItem('sidebarTab', 'task');
        }
        function showSettings(){
          taskPanel.classList.add('hidden');
          settingsPanel.classList.remove('hidden');
          tabTask.className = 'px-2 py-1 text-xs rounded bg-slate-200 text-slate-800';
          tabSettings.className = 'px-2 py-1 text-xs rounded bg-slate-800 text-white';
          localStorage.setItem('sidebarTab', 'settings');
          ensureSettingsLoaded();
        }
        tabTask.addEventListener('click', showTask);
        tabSettings.addEventListener('click', showSettings);
        // restore active tab
        const savedTab = localStorage.getItem('sidebarTab') || 'task';
        if (savedTab === 'settings') showSettings(); else showTask();

        // Settings: fetch and render
        async function ensureSettingsLoaded(){
          if (settingsLoaded) return;
          try {
            const r = await fetch('/api/v1/settings/env');
            if (!r.ok) throw new Error('Failed to load settings');
            const j = await r.json();
            const data = Array.isArray(j.data) ? j.data : [];
            const meta = j.meta || {};
            const tbody = document.getElementById('settingsTable');
            tbody.innerHTML = '';
            data.forEach(e => {
              const tr = document.createElement('tr');
              tr.setAttribute('data-key', e.key || '');
              const tdKey = document.createElement('td'); tdKey.className='px-3 py-2 align-top whitespace-nowrap font-mono text-slate-800';
              tdKey.textContent = e.key || '';
              if (e.is_sensitive){
                const badge = document.createElement('span');
                badge.className = 'ml-2 text-[10px] uppercase tracking-wide bg-rose-100 text-rose-700 rounded px-1 py-0.5';
                badge.textContent = 'sensitive';
                tdKey.appendChild(badge);
              }
              const tdVal = document.createElement('td'); tdVal.className='px-3 py-2 align-top';
              const val = document.createElement('div'); val.className='font-mono text-slate-800 break-all';
              val.setAttribute('data-real', e.value || '');
              val.setAttribute('data-masked', e.masked || '');
              val.setAttribute('data-state', 'masked');
              val.textContent = e.masked || '';
              tdVal.appendChild(val);
              const tdAct = document.createElement('td'); tdAct.className='px-3 py-2 align-top';
              const row = document.createElement('div'); row.className='flex items-center gap-2';
              const btnT = document.createElement('button'); btnT.className='px-2 py-1 text-xs rounded bg-slate-200 text-slate-800'; btnT.textContent='Show';
              btnT.addEventListener('click', ()=>{
                const state = val.getAttribute('data-state') || 'masked';
                if (state === 'masked'){ val.textContent = val.getAttribute('data-real') || ''; val.setAttribute('data-state','shown'); btnT.textContent='Hide'; }
                else { val.textContent = val.getAttribute('data-masked') || ''; val.setAttribute('data-state','masked'); btnT.textContent='Show'; }
              });
              const btnC = document.createElement('button'); btnC.className='px-2 py-1 text-xs rounded bg-slate-700 text-white'; btnC.textContent='Copy';
              btnC.addEventListener('click', async ()=>{
                try { await navigator.clipboard.writeText(val.getAttribute('data-real') || ''); btnC.textContent='Copied'; setTimeout(()=>btnC.textContent='Copy', 1200); }
                catch { btnC.textContent='Failed'; setTimeout(()=>btnC.textContent='Copy', 1200); }
              });
              row.appendChild(btnT); row.appendChild(btnC); tdAct.appendChild(row);
              tr.appendChild(tdKey); tr.appendChild(tdVal); tr.appendChild(tdAct);
              tbody.appendChild(tr);
            });
            const src = document.getElementById('settingsSource');
            if (src) src.textContent = meta.source || '';
            const alert = document.getElementById('settingsFallbackAlert');
            if (alert) {
              if (meta.fallback_used) { alert.textContent = '.env file not found. Displaying a limited subset from process environment.'; alert.classList.remove('hidden'); }
              else { alert.classList.add('hidden'); }
            }
            // filter
            const filter = document.getElementById('settingsFilter');
            filter.addEventListener('input', ()=>{
              const q = (filter.value || '').toLowerCase();
              Array.from(tbody.querySelectorAll('tr')).forEach(tr=>{
                const k = (tr.getAttribute('data-key') || '').toLowerCase();
                tr.style.display = (!q || k.includes(q)) ? '' : 'none';
              });
            });
            settingsLoaded = true;
          } catch (e) {
            const tbody = document.getElementById('settingsTable');
            if (tbody) { tbody.innerHTML = '<tr><td class="px-3 py-2 text-rose-700" colspan="3">Failed to load settings</td></tr>'; }
          }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          const tag = e.target && e.target.tagName;
          const isEditable = (e.target && (e.target.isContentEditable || tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT'));
          if (isEditable) return;
          const k = (e.key || '').toLowerCase();
          // D = delete edge when edge selected
          if (k === 'd' && selectedEdgeId && !selectedNodeId) { e.preventDefault(); deleteSelectedEdge(); return; }
          if (k === 'n') { e.preventDefault(); document.getElementById('btnAddNode').click(); return; }
          if (k === 'e') { e.preventDefault(); document.getElementById('btnAddEdge').click(); return; }
          if (k === 'f') { e.preventDefault(); document.getElementById('btnFit').click(); return; }
          if (e.key === 'Delete') {
            e.preventDefault();
            if (selectedNodeId) { document.getElementById('btnDeleteNodePanel').click(); }
            else if (selectedEdgeId) { deleteSelectedEdge(); }
            return;
          }
          if (k === '/') { e.preventDefault(); document.getElementById('searchBox').focus(); return; }
        });

        // Inline rename project by editing title
        const projTitleEl = document.getElementById('projTitle');
        async function commitProjectTitle(){
          const name = (projTitleEl.textContent || '').trim();
          if (!name) return;
          try {
            const resp = await patchJSON(`/api/v1/projects/${projectId}`, { name });
            document.title = `${resp.data.name} - Graph`;
            projTitleEl.textContent = resp.data.name;
          } catch(e) { /* ignore */ }
        }
        projTitleEl.addEventListener('keydown', (e)=>{ if (e.key==='Enter'){ e.preventDefault(); projTitleEl.blur(); }});
        projTitleEl.addEventListener('blur', commitProjectTitle);

        // Export JSON (nodes+edges)
        document.getElementById('btnExportJSON').addEventListener('click', async () => {
          const nodes = await fetch(`/api/v1/projects/${projectId}/nodes`).then(r=>r.json());
          const edges = await fetch(`/api/v1/projects/${projectId}/edges`).then(r=>r.json());
          const blob = new Blob([JSON.stringify({nodes: nodes.data, edges: edges.data}, null, 2)], {type: 'application/json'});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = `project-${projectId}.json`; a.click();
          URL.revokeObjectURL(url);
        });

        // Import JSON (append)
        document.getElementById('importInput').addEventListener('change', async (e) => {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          const text = await file.text();
          const data = JSON.parse(text);
          for (const n of (data.nodes || [])) {
            await postJSON(`/api/v1/projects/${projectId}/nodes`, { title: n.title || n.id, description: n.description || '' });
          }
          // reload graph after import to get IDs and edges correct
          graph = await fetchGraph();
          cy.elements().remove();
          cy.add(toElements(graph));
          cy.layout({ name: 'preset' }).run();
        });

        // Screenshot PNG
        document.getElementById('btnScreenshot').addEventListener('click', () => {
          const png = cy.png({full: true, scale: 2});
          const a = document.createElement('a');
          a.href = png; a.download = `graph-${projectId}.png`; a.click();
        });

        // Onboarding overlay
        const help = document.getElementById('btnHelp');
        help.addEventListener('click', () => {
          alert('Shortcuts: n=new node, e=new edge, f=fit, /=search. Use toolbar to manage nodes/edges, sidebar for comments/time/cost.');
        });

        // Persist position after drag
        cy.on('dragfree', 'node', async (evt) => {
          const n = evt.target;
          const p = n.position();
          try {
            await postJSON(`/api/v1/nodes/${n.id()}/position`, { x: p.x, y: p.y });
            n.data('savedX', p.x);
            n.data('savedY', p.y);
          } catch (e) { /* ignore */ }
        });
      })();
    </script>
  </body>
  </html>

