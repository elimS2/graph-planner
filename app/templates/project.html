<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>{{ project.name }} - Graph</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
    <script src="https://unpkg.com/cytoscape-edgehandles@4.0.1/cytoscape-edgehandles.min.js"></script>
  </head>
  <body class="min-h-screen bg-slate-50 text-slate-900">
    <div class="flex flex-col h-screen">
      <div class="flex items-center justify-between px-4 py-3">
        <h1 class="text-2xl font-semibold">{{ project.name }}</h1>
        <div class="flex items-center gap-3">
          <button id="btnRenameProject" class="px-3 py-1 bg-blue-600 text-white rounded">Rename</button>
          <span id="userEmail" class="text-sm text-slate-600 hidden"></span>
          <button id="btnLogin" class="px-3 py-1 bg-slate-700 text-white rounded">Login</button>
          <button id="btnLogout" class="px-3 py-1 bg-slate-500 text-white rounded hidden">Logout</button>
          <a class="text-blue-600 underline" href="/">Home</a>
        </div>
      </div>

      <div class="flex flex-1 overflow-hidden">
        <div class="flex-1 flex flex-col min-w-0">
          <div class="px-4 pb-3 flex flex-wrap gap-2 items-center">
            <input id="searchBox" type="text" placeholder="Search nodes..." class="border rounded px-2 py-1" />
            <select id="statusFilter" class="border rounded px-2 py-1">
              <option value="">All</option>
              <option value="planned">Todo</option>
              <option value="in-progress">In Progress</option>
              <option value="done">Done</option>
              <option value="blocked">Blocked</option>
            </select>
            <button id="btnAddNode" class="px-3 py-1 bg-blue-600 text-white rounded">+ Node</button>
            <button id="btnAddEdge" class="px-3 py-1 bg-indigo-600 text-white rounded">+ Edge</button>
            <button id="btnDeleteEdge" class="px-3 py-1 bg-rose-500 text-white rounded">Delete Edge</button>
            <button id="btnCriticalPath" class="px-3 py-1 bg-teal-600 text-white rounded">Critical Path</button>
            <button id="btnGroup" class="px-3 py-1 bg-purple-600 text-white rounded">Group</button>
            <button id="btnUngroup" class="px-3 py-1 bg-purple-500 text-white rounded">Ungroup</button>
            <button id="btnCollapse" class="px-3 py-1 bg-fuchsia-600 text-white rounded">Collapse</button>
            <button id="btnExpand" class="px-3 py-1 bg-fuchsia-500 text-white rounded">Expand</button>
            <button id="btnFit" class="px-3 py-1 bg-slate-600 text-white rounded">Fit</button>
            <button id="btnExportJSON" class="px-3 py-1 bg-slate-700 text-white rounded">Export JSON</button>
            <label class="px-3 py-1 bg-slate-700 text-white rounded cursor-pointer">Import JSON<input id="importInput" type="file" accept="application/json" class="hidden" /></label>
            <button id="btnScreenshot" class="px-3 py-1 bg-slate-700 text-white rounded">Screenshot</button>
            <button id="btnHelp" class="px-3 py-1 bg-slate-500 text-white rounded">Help</button>
            <button id="btnToggleSidebar" class="ml-auto px-3 py-1 bg-slate-200 text-slate-800 rounded">Toggle Sidebar</button>
          </div>
          <div id="cy" class="flex-1 min-h-0 bg-white rounded shadow mx-4 mb-4"></div>
        </div>
        <div id="resizer" class="w-1 cursor-col-resize bg-slate-200"></div>
        <aside id="sidebar" class="bg-white rounded-l-none rounded shadow p-4 space-y-4 overflow-auto" style="width: 384px;">
          <h2 class="font-medium">Task Panel</h2>
          <div>
            <label class="block text-sm text-slate-600">Selected Node Title</label>
            <div id="selNodeTitle" contenteditable="true" spellcheck="false" class="text-sm text-slate-800 truncate border rounded px-2 py-1 focus:outline-none focus:ring focus:ring-slate-300">—</div>
          </div>
          <div>
            <label class="block text-sm text-slate-600">Selected Node ID</label>
            <div id="selNode" class="text-sm font-mono text-slate-800">—</div>
          </div>
          <div>
            <label class="block text-sm text-slate-600">Created At</label>
            <div id="createdAt" class="text-sm text-slate-800">—</div>
          </div>
          <div>
            <label class="block text-sm">Status</label>
            <select id="statusSelect" class="w-full border rounded p-2">
              <option value="planned">todo</option>
              <option value="in-progress">in-progress</option>
              <option value="done">done</option>
              <option value="blocked">blocked</option>
            </select>
          </div>
          <div>
            <label class="block text-sm text-slate-600">Descendants (via edges)</label>
            <div id="descCount" class="text-sm text-slate-800">0</div>
          </div>
          <div>
            <h3 class="text-sm font-semibold">Comments</h3>
            <ul id="commentsList" class="text-sm space-y-1 max-h-32 overflow-auto"></ul>
          </div>
          <div>
            <h3 class="text-sm font-semibold">Status History</h3>
            <ul id="statusHistory" class="text-sm space-y-1 max-h-24 overflow-auto"></ul>
          </div>
          <form id="commentForm" class="space-y-2">
            <div>
              <label class="block text-sm">Comment</label>
              <textarea name="body" class="w-full border rounded p-2" rows="3" placeholder="Write a comment"></textarea>
            </div>
            <input type="hidden" name="user_id" value="system-user" />
            <button type="submit" class="px-3 py-1 bg-blue-600 text-white rounded">Add Comment</button>
          </form>
          <div>
            <h3 class="text-sm font-semibold">Time</h3>
            <ul id="timeList" class="text-sm space-y-1 max-h-24 overflow-auto"></ul>
          </div>
          <form id="timeForm" class="space-y-2">
            <div>
              <label class="block text-sm">Hours</label>
              <input name="hours" type="number" step="0.1" class="w-full border rounded p-2" placeholder="1.0" />
            </div>
            <input type="hidden" name="user_id" value="system-user" />
            <button type="submit" class="px-3 py-1 bg-emerald-600 text-white rounded">Add Time</button>
          </form>
          <div>
            <h3 class="text-sm font-semibold">Costs</h3>
            <ul id="costList" class="text-sm space-y-1 max-h-24 overflow-auto"></ul>
          </div>
          <form id="costForm" class="space-y-2">
            <div>
              <label class="block text-sm">Amount</label>
              <input name="amount" type="number" step="0.01" class="w-full border rounded p-2" placeholder="100" />
            </div>
            <button type="submit" class="px-3 py-1 bg-amber-600 text-white rounded">Add Cost</button>
          </form>
          <div>
            <button id="btnDeleteNodePanel" class="w-full mt-2 px-3 py-2 bg-rose-600 text-white rounded hidden">Delete Node</button>
          </div>
        </aside>
      </div>
    </div>

    <script>
      const projectId = "{{ project.id }}";

      function formatDate(iso) {
        if (!iso) return '—';
        const d = new Date(iso);
        if (isNaN(d.getTime())) return String(iso);
        try {
          const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
          const base = new Intl.DateTimeFormat(navigator.language || 'en-US', {
            year: 'numeric', month: 'short', day: '2-digit',
            hour: '2-digit', minute: '2-digit', hour12: false,
            timeZoneName: 'short'
          }).format(d);
          return `${base} (${tz})`;
        } catch { return d.toLocaleString(); }
      }

      async function apiMe(){
        const r = await fetch('/api/v1/auth/me');
        const j = await r.json();
        return j && j.data;
      }
      async function apiLogin(email, password){
        const r = await fetch('/api/v1/auth/login', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({email, password})});
        if (!r.ok) throw new Error('Login failed');
        return r.json();
      }
      async function apiLogout(){ await fetch('/api/v1/auth/logout', {method:'POST'}); }

      function wireAuthHeader(){
        const emailEl = document.getElementById('userEmail');
        const btnLogin = document.getElementById('btnLogin');
        const btnLogout = document.getElementById('btnLogout');
        async function refresh(){
          const me = await apiMe();
          if (me && me.id){
            emailEl.textContent = me.id;
            emailEl.classList.remove('hidden');
            btnLogout.classList.remove('hidden');
            btnLogin.classList.add('hidden');
          } else {
            emailEl.classList.add('hidden');
            btnLogout.classList.add('hidden');
            btnLogin.classList.remove('hidden');
          }
        }
        btnLogin.addEventListener('click', async ()=>{
          const email = prompt('Email');
          const password = prompt('Password');
          if (!email || !password) return;
          try { await apiLogin(email, password); } catch { alert('Invalid credentials'); }
          refresh();
        });
        btnLogout.addEventListener('click', async ()=>{ await apiLogout(); refresh(); });
        refresh();
      }

      async function fetchGraph() {
        const [nodesRes, edgesRes] = await Promise.all([
          fetch(`/api/v1/projects/${projectId}/nodes`),
          fetch(`/api/v1/projects/${projectId}/edges`),
        ]);
        const nodesJson = await nodesRes.json();
        const edgesJson = await edgesRes.json();
        return { nodes: nodesJson.data, edges: edgesJson.data };
      }

      function toElements(graph) {
        const dotIcon = 'data:image/svg+xml;utf8,' + encodeURIComponent(
          '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">\
            <circle cx="25" cy="25" r="12" fill="#0f172a"/>\
            <circle cx="75" cy="25" r="12" fill="#0f172a"/>\
            <circle cx="25" cy="75" r="12" fill="#0f172a"/>\
            <circle cx="75" cy="75" r="12" fill="#0f172a"/>\
            <circle cx="50" cy="50" r="12" fill="#0f172a"/>\
          </svg>'
        );
        const nodes = graph.nodes.map(n => ({
          data: {
            id: String(n.id),
            label: n.title,
            score: n.importance_score,
            status: n.status,
            is_group: !!n.is_group,
            parent: (n.parent_id !== null && n.parent_id !== undefined) ? String(n.parent_id) : undefined,
            dotIcon: dotIcon,
            savedX: (n.position && typeof n.position.x === 'number') ? n.position.x : null,
            savedY: (n.position && typeof n.position.y === 'number') ? n.position.y : null,
            created_at: n.created_at
          },
          position: n.position
        }));
        const edges = graph.edges.map(e => ({ data: { id: String(e.id), source: String(e.source_node_id), target: String(e.target_node_id), type: e.type, weight: e.weight }}));
        return [...nodes, ...edges];
      }

      (async function init() {
        wireAuthHeader();
        let graph = await fetchGraph();
        const allHavePositions = Array.isArray(graph.nodes) && graph.nodes.length > 0 && graph.nodes.every(n => n.position && typeof n.position.x === 'number' && typeof n.position.y === 'number');
        const cy = cytoscape({
          container: document.getElementById('cy'),
          elements: toElements(graph),
          style: [
            { selector: 'node', style: { 'label': 'data(label)', 'text-valign': 'center', 'color': '#0f172a', 'background-color': '#38bdf8', 'width': 'mapData(score, 0, 10, 20, 60)', 'height': 'mapData(score, 0, 10, 20, 60)'} },
            { selector: 'edge', style: { 'line-color': '#64748b', 'width': 1.5, 'curve-style': 'bezier', 'target-arrow-color': '#64748b', 'target-arrow-shape': 'triangle', 'arrow-scale': 1.2 } },
            { selector: 'edge:hover', style: { 'line-color': '#334155', 'target-arrow-color': '#334155', 'width': 2.5, 'arrow-scale': 1.5 } },
            { selector: 'edge:selected', style: { 'line-color': '#0ea5e9', 'target-arrow-color': '#0ea5e9', 'width': 2.5, 'arrow-scale': 1.5 } },
            { selector: 'node[status = "planned"]', style: { 'background-color': '#38bdf8' } },
            { selector: 'node[status = "done"]', style: { 'background-color': '#22c55e' } },
            { selector: 'node[status = "in-progress"]', style: { 'background-color': '#f59e0b' } },
            { selector: 'node[status = "blocked"]', style: { 'background-color': '#ef4444' } },
            { selector: '.cp', style: { 'border-width': 4, 'border-color': '#14b8a6' } },
            { selector: 'node[?is_group]', style: {
                'shape': 'ellipse',
                'width': 'mapData(score, 0, 10, 28, 68)',
                'height': 'mapData(score, 0, 10, 28, 68)',
                'border-width': 0,
                'border-color': '#0f172a',
                'border-opacity': 0,
                'background-opacity': 0,
                'background-color': 'transparent'
              }
            },
            { selector: 'node.collapsed', style: {
                'background-image': 'data(dotIcon)',
                'background-fit': 'contain',
                'background-width': '65%',
                'background-height': '65%',
                'background-position-x': '50%',
                'background-position-y': '50%',
                'background-repeat': 'no-repeat'
              }
            },
          ],
          layout: { name: allHavePositions ? 'preset' : 'preset' }
        });
        cy.fit();

        // Enable drag-to-connect (edgehandles)
        try {
          const eh = cy.edgehandles({
            toggleOffOnLeave: true,
            handleNodes: 'node',
            handleSize: 12,
            handleColor: '#0ea5e9',
            handleLineType: 'straight',
            handleLineWidth: 2,
            snap: true,
            noEdgeEventsInDraw: true
          });
          cy.on('ehcomplete', async (event, sourceNode, targetNode, addedEles) => {
            try {
              const resp = await postJSON(`/api/v1/projects/${projectId}/edges`, { source_node_id: sourceNode.id(), target_node_id: targetNode.id() });
              // Replace temp edge with server one
              if (addedEles && addedEles.length) addedEles.remove();
              addEdgeToCy(resp.data);
            } catch { alert('Edge creation failed'); }
          });
        } catch(e) { /* ignore if plugin not available */ }

        function applyInitialPositions() {
          // Set saved positions for nodes that have them
          cy.nodes().forEach(n => {
            const x = n.data('savedX');
            const y = n.data('savedY');
            if (typeof x === 'number' && typeof y === 'number') {
              n.position({ x, y });
            }
          });
          // Layout only nodes without saved positions
          const needLayout = cy.nodes().filter(n => !(typeof n.data('savedX') === 'number' && typeof n.data('savedY') === 'number'));
          if (needLayout.length > 0) {
            needLayout.layout({ name: 'cose' }).run();
          }
        }
        applyInitialPositions();

        const selEl = document.getElementById('selNode');
        let selectedNodeId = null;
        let selectedEdgeId = null;
        async function refreshLists(nodeId) {
          const [c, t, k] = await Promise.all([
            fetch(`/api/v1/nodes/${nodeId}/comments`).then(r=>r.json()),
            fetch(`/api/v1/nodes/${nodeId}/time-entries`).then(r=>r.json()),
            fetch(`/api/v1/nodes/${nodeId}/cost-entries`).then(r=>r.json()),
          ]);
          const commentsList = document.getElementById('commentsList');
          commentsList.innerHTML = '';
          c.data.forEach(x => {
            const li = document.createElement('li');
            const body = document.createElement('span'); body.textContent = x.body;
            const time = document.createElement('span'); time.className = 'ml-2 text-xs text-slate-500'; time.textContent = formatDate(x.created_at);
            li.appendChild(body); li.appendChild(time);
            commentsList.appendChild(li);
          });
          const timeList = document.getElementById('timeList');
          timeList.innerHTML = '';
          t.data.forEach(x => {
            const li = document.createElement('li');
            li.textContent = `${x.hours}h`;
            timeList.appendChild(li);
          });
          const costList = document.getElementById('costList');
          costList.innerHTML = '';
          k.data.forEach(x => {
            const li = document.createElement('li');
            const amt = document.createElement('span'); amt.textContent = `${x.amount} ${x.currency || 'USD'}`;
            const when = document.createElement('span'); when.className = 'ml-2 text-xs text-slate-500'; when.textContent = formatDate(x.incurred_at);
            li.appendChild(amt); li.appendChild(when);
            costList.appendChild(li);
          });
          // status history
          try {
            const h = await fetch(`/api/v1/nodes/${nodeId}/status-history`).then(r=>r.json());
            const sh = document.getElementById('statusHistory');
            sh.innerHTML = '';
            (h.data || []).forEach(x => {
              const li = document.createElement('li');
              li.textContent = `${x.old_status} → ${x.new_status}`;
              const when = document.createElement('span'); when.className = 'ml-2 text-xs text-slate-500'; when.textContent = formatDate(x.created_at);
              li.appendChild(when);
              sh.appendChild(li);
            });
          } catch {}
        }

        cy.on('tap', 'node', async (evt) => {
          selectedNodeId = evt.target.data('id');
          selEl.textContent = selectedNodeId;
          const titleEl = document.getElementById('selNodeTitle');
          if (titleEl) titleEl.textContent = String(evt.target.data('label') || '—');
          const createdEl = document.getElementById('createdAt');
          if (createdEl) createdEl.textContent = formatDate(evt.target.data('created_at'));
          const delBtn = document.getElementById('btnDeleteNodePanel');
          if (delBtn) delBtn.classList.remove('hidden');
          // compute descendants via outgoing edges (reachability)
          const start = cy.getElementById(selectedNodeId);
          let count = 0;
          if (start && start.nonempty()) {
            const visited = new Set([start.id()]);
            const queue = [start];
            while (queue.length) {
              const cur = queue.shift();
              const out = cur.outgoers('edge');
              out.targets().forEach(t => {
                if (!visited.has(t.id())) { visited.add(t.id()); queue.push(t); count++; }
              });
            }
          }
          const dc = document.getElementById('descCount');
          if (dc) dc.textContent = String(count);
          selectedEdgeId = null;
          // set status select to node status
          const sel = document.getElementById('statusSelect');
          if (sel) sel.value = String(evt.target.data('status') || 'planned');
          await refreshLists(selectedNodeId);
        });
        cy.on('tap', 'edge', (evt) => {
          selectedEdgeId = evt.target.data('id');
          selectedNodeId = null;
          selEl.textContent = '—';
          const delBtn = document.getElementById('btnDeleteNodePanel');
          if (delBtn) delBtn.classList.add('hidden');
        });

        async function postJSON(url, data) {
          const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) });
          if (res.status === 401) { alert('Login required'); throw new Error('Unauthorized'); }
          if (!res.ok) throw new Error('Request failed');
          return res.json();
        }
        async function patchJSON(url, data) {
          const res = await fetch(url, { method: 'PATCH', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) });
          if (res.status === 401) { alert('Login required'); throw new Error('Unauthorized'); }
          if (!res.ok) throw new Error('Request failed');
          return res.json();
        }
        async function del(url) {
          const res = await fetch(url, { method: 'DELETE' });
          if (res.status === 401) { alert('Login required'); throw new Error('Unauthorized'); }
          if (!res.ok && res.status !== 204) throw new Error('Request failed');
        }

        function addNodeToCy(n) {
          const ext = cy.extent();
          const padding = 30;
          const pos = { x: ext.x1 + padding, y: ext.y1 + padding };
          cy.add({ group: 'nodes', data: { id: n.id, label: n.title, score: n.importance_score || 0, status: n.status || 'todo', savedX: pos.x, savedY: pos.y }, position: pos });
          // Persist initial position best-effort
          postJSON(`/api/v1/nodes/${n.id}/position`, { x: pos.x, y: pos.y }).catch(()=>{});
        }
        function addEdgeToCy(e) {
          cy.add({ group: 'edges', data: { id: e.id, source: e.source_node_id, target: e.target_node_id, type: e.type, weight: e.weight } });
          cy.layout({ name: 'preset' }).run();
          cy.fit();
        }

        document.getElementById('commentForm').addEventListener('submit', async (e) => {
          e.preventDefault();
          if (!selectedNodeId) return;
          const fd = new FormData(e.target);
          await postJSON(`/api/v1/nodes/${selectedNodeId}/comments`, { user_id: fd.get('user_id'), body: fd.get('body') });
          e.target.reset();
          await refreshLists(selectedNodeId);
        });

        document.getElementById('timeForm').addEventListener('submit', async (e) => {
          e.preventDefault();
          if (!selectedNodeId) return;
          const fd = new FormData(e.target);
          await postJSON(`/api/v1/nodes/${selectedNodeId}/time-entries`, { user_id: fd.get('user_id'), hours: parseFloat(fd.get('hours')) || 0 });
          e.target.reset();
          await refreshLists(selectedNodeId);
        });

        // Status selector change handler
        document.getElementById('statusSelect').addEventListener('change', async (e) => {
          if (!selectedNodeId) return;
          const value = e.target.value;
          const resp = await patchJSON(`/api/v1/nodes/${selectedNodeId}`, { status: value });
          const n = cy.getElementById(selectedNodeId);
          n.data('status', resp.data.status);
        });

        document.getElementById('costForm').addEventListener('submit', async (e) => {
          e.preventDefault();
          if (!selectedNodeId) return;
          const fd = new FormData(e.target);
          await postJSON(`/api/v1/nodes/${selectedNodeId}/cost-entries`, { amount: parseFloat(fd.get('amount')) || 0, currency: 'USD', incurred_at: new Date().toISOString() });
          e.target.reset();
          await refreshLists(selectedNodeId);
        });

        document.getElementById('btnAddNode').addEventListener('click', async () => {
          const title = prompt('Node title');
          if (!title) return;
          const resp = await postJSON(`/api/v1/projects/${projectId}/nodes`, { title });
          addNodeToCy(resp.data);
        });

        // Removed old Edit Node toolbar flow (replaced by inline editor)

        // Inline edit selected node title (Task Panel)
        const titleInlineEl = document.getElementById('selNodeTitle');
        function commitInlineTitle(){
          if (!selectedNodeId) return;
          const newTitle = (titleInlineEl.textContent || '').trim();
          if (!newTitle) { return; }
          patchJSON(`/api/v1/nodes/${selectedNodeId}`, { title: newTitle })
            .then(resp => {
              const n = cy.getElementById(selectedNodeId);
              if (n) n.data('label', resp.data.title);
            })
            .catch(()=>{});
        }
        titleInlineEl.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') { e.preventDefault(); commitInlineTitle(); titleInlineEl.blur(); }
        });
        titleInlineEl.addEventListener('blur', () => commitInlineTitle());

        document.getElementById('btnDeleteNodePanel').addEventListener('click', async () => {
          if (!selectedNodeId) { alert('Select a node'); return; }
          if (!confirm('Delete node?')) return;
          await del(`/api/v1/nodes/${selectedNodeId}`);
          cy.getElementById(selectedNodeId).remove();
          selectedNodeId = null;
          selEl.textContent = '—';
        });

        document.getElementById('btnAddEdge').addEventListener('click', async () => {
          alert('Pick source node, then target node');
          let sourceId = null;
          const pickHandler = (evt) => {
            if (!sourceId) {
              sourceId = evt.target.data('id');
            } else {
              const targetId = evt.target.data('id');
              cy.off('tap', 'node', pickHandler);
              postJSON(`/api/v1/projects/${projectId}/edges`, { source_node_id: sourceId, target_node_id: targetId })
                .then(resp => addEdgeToCy(resp.data))
                .catch(() => alert('Edge creation failed'));
            }
          };
          cy.on('tap', 'node', pickHandler);
        });

        document.getElementById('btnDeleteEdge').addEventListener('click', async () => {
          if (!selectedEdgeId) { alert('Tap an edge to select it'); return; }
          if (!confirm('Delete edge?')) return;
          await del(`/api/v1/edges/${selectedEdgeId}`);
          cy.getElementById(selectedEdgeId).remove();
          selectedEdgeId = null;
        });

        document.getElementById('btnCriticalPath').addEventListener('click', async () => {
          const res = await fetch(`/api/v1/projects/${projectId}/metrics`).then(r=>r.json());
          const ids = (res.data && res.data.critical_path_hint && res.data.critical_path_hint.node_ids) || [];
          cy.elements().removeClass('cp');
          ids.forEach((id, i) => {
            const el = cy.getElementById(id);
            el.addClass('cp');
          });
        });

        // Multi-select (hold Shift to select multiple)
        let multiSelected = new Set();
        cy.on('tap', 'node', (evt) => {
          if (evt.originalEvent && evt.originalEvent.shiftKey) {
            const id = evt.target.id();
            if (multiSelected.has(id)) multiSelected.delete(id); else multiSelected.add(id);
            evt.target.toggleClass('cp');
          } else {
            multiSelected.clear();
          }
        });

        document.getElementById('btnGroup').addEventListener('click', async () => {
          if (multiSelected.size < 1) { alert('Hold Shift and select nodes to group'); return; }
          const title = prompt('Group title', 'Group') || 'Group';
          const ids = Array.from(multiSelected);
          const res = await postJSON(`/api/v1/projects/${projectId}/groups`, { title, node_ids: ids });
          // reload graph for simplicity
          graph = await fetchGraph();
          cy.elements().remove();
          cy.add(toElements(graph));
          cy.layout({ name: 'preset' }).run();
          cy.fit();
          multiSelected.clear();
        });

        document.getElementById('btnUngroup').addEventListener('click', async () => {
          if (!selectedNodeId) { alert('Select a group node'); return; }
          const nd = cy.getElementById(selectedNodeId);
          if (!nd || !nd.data('is_group')) { alert('Selected node is not a group'); return; }
          await postJSON(`/api/v1/groups/${selectedNodeId}/ungroup`, {});
          graph = await fetchGraph();
          cy.elements().remove();
          cy.add(toElements(graph));
          cy.layout({ name: 'preset' }).run();
        });

        // Collapse / Expand groups (pure UI)
        const collapsedGroups = new Set((JSON.parse(localStorage.getItem('collapsedGroups') || '[]') || []).map(String));
        function persistCollapsed() {
          localStorage.setItem('collapsedGroups', JSON.stringify(Array.from(collapsedGroups)));
        }
        function collapseGroup(groupId) {
          const gid = String(groupId);
          const children = cy.nodes().filter(n => String(n.data('parent')) === gid);
          children.forEach(ch => { ch.data('origParent', gid); ch.move({ parent: null }); ch.style('display', 'none'); });
          const grp = cy.getElementById(groupId);
          if (grp) grp.addClass('collapsed');
        }
        function expandGroup(groupId) {
          const gid = String(groupId);
          const children = cy.nodes().filter(n => String(n.data('origParent')) === gid);
          children.forEach(ch => { ch.move({ parent: gid }); ch.removeData('origParent'); ch.style('display', 'element'); });
          const grp = cy.getElementById(groupId);
          if (grp) grp.removeClass('collapsed');
        }
        // Apply persisted states after initial render
        // 1) Collapse ALL groups by default
        cy.nodes('[?is_group]').forEach(g => collapseGroup(g.id()));
        // 2) Expand those that are not in persisted collapsed set
        cy.nodes('[?is_group]').forEach(g => {
          if (!collapsedGroups.has(String(g.id()))) {
            expandGroup(g.id());
          }
        });

        // 3) Re-apply saved positions for groups to override any layout shifts
        function reapplySavedGroupPositions() {
          cy.nodes('[?is_group]').forEach(g => {
            const x = g.data('savedX');
            const y = g.data('savedY');
            if (typeof x === 'number' && typeof y === 'number') {
              g.position({ x, y });
            }
          });
        }
        reapplySavedGroupPositions();

        document.getElementById('btnCollapse').addEventListener('click', () => {
          if (!selectedNodeId) { alert('Select a group node'); return; }
          const nd = cy.getElementById(selectedNodeId);
          if (!nd || !nd.data('is_group')) { alert('Selected node is not a group'); return; }
          collapseGroup(selectedNodeId);
          collapsedGroups.add(selectedNodeId);
          persistCollapsed();
        });

        document.getElementById('btnExpand').addEventListener('click', () => {
          if (!selectedNodeId) { alert('Select a group node'); return; }
          const nd = cy.getElementById(selectedNodeId);
          if (!nd || !nd.data('is_group')) { alert('Selected node is not a group'); return; }
          expandGroup(selectedNodeId);
          collapsedGroups.delete(selectedNodeId);
          persistCollapsed();
        });

        // Double-click (fast two taps) on group to toggle collapse/expand
        let lastTapAt = 0;
        let lastTapId = null;
        cy.on('tap', 'node', (evt) => {
          // ignore when using Shift multi-select
          if (evt.originalEvent && evt.originalEvent.shiftKey) return;
          const id = evt.target.id();
          const now = Date.now();
          if (evt.target.data('is_group') && lastTapId === id && (now - lastTapAt) < 300) {
            const isCollapsed = collapsedGroups.has(id);
            if (isCollapsed) { expandGroup(id); collapsedGroups.delete(id); }
            else { collapseGroup(id); collapsedGroups.add(id); }
            persistCollapsed();
            lastTapAt = 0; lastTapId = null;
          } else {
            lastTapAt = now; lastTapId = id;
          }
        });

        // LOD: hide nodes below threshold depending on zoom level
        function applyLOD() {
          const z = cy.zoom();
          const total = cy.nodes().length;
          // Only hide at low zoom for sufficiently large graphs
          let threshold = -1;
          if (total > 100) {
            if (z < 0.4) threshold = 1.5;
            else if (z < 0.8) threshold = 0.6;
            else threshold = -1;
          }

          let shown = 0;
          cy.nodes().forEach(n => {
            const score = n.data('score') || 0;
            const isSelected = selectedNodeId && n.id() === selectedNodeId;
            const isCollapsedChild = Boolean(n.data('origParent'));
            const visible = !isCollapsedChild && (threshold < 0 || score >= threshold || isSelected);
            n.style('display', visible ? 'element' : 'none');
            if (visible) shown++;
          });

          // Safety: if nothing would be visible, show all
          if (shown === 0) {
            cy.nodes().forEach(n => {
              if (!n.data('origParent')) n.style('display', 'element');
            });
          }
        }
        cy.on('zoom', applyLOD);
        applyLOD();

        // Search/filter
        function applySearchAndFilter() {
          const q = (document.getElementById('searchBox').value || '').toLowerCase();
          const f = (document.getElementById('statusFilter').value || '').toLowerCase();
          cy.nodes().forEach(n => {
            const matchesText = !q || (String(n.data('label') || '').toLowerCase().includes(q));
            // Internal status uses 'planned' for what UI calls 'Todo'
            const statusValue = String(n.data('status') || '').toLowerCase();
            const filterValue = f === 'planned' ? 'planned' : f;
            const matchesStatus = !f || (statusValue === filterValue);
            n.style('opacity', (matchesText && matchesStatus) ? 1 : 0.15);
          });
        }
        document.getElementById('searchBox').addEventListener('input', applySearchAndFilter);
        document.getElementById('statusFilter').addEventListener('change', applySearchAndFilter);

        // Fit
        document.getElementById('btnFit').addEventListener('click', () => cy.fit());

        // Toggle sidebar
        const sidebar = document.getElementById('sidebar');
        const toggleBtn = document.getElementById('btnToggleSidebar');
        function applySidebarVisibility(){
          const hidden = localStorage.getItem('sidebarHidden') === '1';
          if (hidden) {
            sidebar.style.display = 'none';
          } else {
            sidebar.style.display = '';
          }
          setTimeout(() => cy.resize(), 0);
        }
        toggleBtn.addEventListener('click', () => {
          const hidden = localStorage.getItem('sidebarHidden') === '1';
          localStorage.setItem('sidebarHidden', hidden ? '0' : '1');
          applySidebarVisibility();
        });
        applySidebarVisibility();

        // Sidebar resizer
        (function setupResizer(){
          const resizer = document.getElementById('resizer');
          const sidebar = document.getElementById('sidebar');
          function loadWidth(){
            const w = parseInt(localStorage.getItem('sidebarWidth') || '384', 10);
            const clamped = Math.max(260, Math.min(560, w));
            sidebar.style.width = clamped + 'px';
          }
          loadWidth();
          let dragging = false;
          let startX = 0;
          let startW = 384;
          resizer.addEventListener('mousedown', (e) => {
            dragging = true; startX = e.clientX; startW = sidebar.offsetWidth;
            document.body.classList.add('select-none'); document.body.style.cursor = 'col-resize';
            e.preventDefault();
          });
          window.addEventListener('mouseup', () => {
            if (!dragging) return;
            dragging = false;
            document.body.classList.remove('select-none');
            document.body.style.cursor = '';
            localStorage.setItem('sidebarWidth', parseInt(sidebar.style.width||'384',10));
          });
          window.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            // Dragging left should INCREASE width, right should decrease
            const delta = startX - e.clientX; // left: positive, right: negative
            const newW = Math.max(260, Math.min(560, startW + delta));
            sidebar.style.width = newW + 'px';
            cy.resize();
          });
          // Hide resizer if sidebar hidden
          function syncResizer(){ resizer.style.display = (localStorage.getItem('sidebarHidden') === '1') ? 'none' : ''; }
          syncResizer();
          toggleBtn.addEventListener('click', () => { setTimeout(() => { syncResizer(); cy.resize(); }, 0); });
        })();

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          if (e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA')) return;
          if (e.key === 'n') document.getElementById('btnAddNode').click();
          if (e.key === 'e') document.getElementById('btnAddEdge').click();
          if (e.key === 'f') document.getElementById('btnFit').click();
          if (e.key === 'Delete') document.getElementById(selectedNodeId ? 'btnDeleteNodePanel' : 'btnDeleteEdge').click();
          if (e.key === '/' ) document.getElementById('searchBox').focus();
        });

        // Rename project
        document.getElementById('btnRenameProject').addEventListener('click', async () => {
          const cur = document.title.replace(' - Graph','');
          const name = prompt('New board name', cur);
          if (!name) return;
          try {
            const resp = await patchJSON(`/api/v1/projects/${projectId}`, { name });
            document.title = `${resp.data.name} - Graph`;
            document.querySelector('h1').textContent = resp.data.name;
            alert('Board renamed');
          } catch(e) { alert('Rename failed'); }
        });

        // Export JSON (nodes+edges)
        document.getElementById('btnExportJSON').addEventListener('click', async () => {
          const nodes = await fetch(`/api/v1/projects/${projectId}/nodes`).then(r=>r.json());
          const edges = await fetch(`/api/v1/projects/${projectId}/edges`).then(r=>r.json());
          const blob = new Blob([JSON.stringify({nodes: nodes.data, edges: edges.data}, null, 2)], {type: 'application/json'});
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = `project-${projectId}.json`; a.click();
          URL.revokeObjectURL(url);
        });

        // Import JSON (append)
        document.getElementById('importInput').addEventListener('change', async (e) => {
          const file = e.target.files && e.target.files[0];
          if (!file) return;
          const text = await file.text();
          const data = JSON.parse(text);
          for (const n of (data.nodes || [])) {
            await postJSON(`/api/v1/projects/${projectId}/nodes`, { title: n.title || n.id, description: n.description || '' });
          }
          // reload graph after import to get IDs and edges correct
          graph = await fetchGraph();
          cy.elements().remove();
          cy.add(toElements(graph));
          cy.layout({ name: 'preset' }).run();
        });

        // Screenshot PNG
        document.getElementById('btnScreenshot').addEventListener('click', () => {
          const png = cy.png({full: true, scale: 2});
          const a = document.createElement('a');
          a.href = png; a.download = `graph-${projectId}.png`; a.click();
        });

        // Onboarding overlay
        const help = document.getElementById('btnHelp');
        help.addEventListener('click', () => {
          alert('Shortcuts: n=new node, e=new edge, f=fit, /=search. Use toolbar to manage nodes/edges, sidebar for comments/time/cost.');
        });

        // Persist position after drag
        cy.on('dragfree', 'node', async (evt) => {
          const n = evt.target;
          const p = n.position();
          try {
            await postJSON(`/api/v1/nodes/${n.id()}/position`, { x: p.x, y: p.y });
            n.data('savedX', p.x);
            n.data('savedY', p.y);
          } catch (e) { /* ignore */ }
        });
      })();
    </script>
  </body>
  </html>

